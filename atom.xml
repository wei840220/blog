<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>學海無涯，回頭是岸</title>
  
  <subtitle>Wei 的前端技術部落格</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.weitw.net/"/>
  <updated>2019-12-27T17:27:41.866Z</updated>
  <id>https://blog.weitw.net/</id>
  
  <author>
    <name>Wei</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>什麼是 SSL？讓 Cloudflare 幫你啟用 HTTPS</title>
    <link href="https://blog.weitw.net/posts/747bdc82/"/>
    <id>https://blog.weitw.net/posts/747bdc82/</id>
    <published>2019-12-22T17:24:59.000Z</published>
    <updated>2019-12-27T17:27:41.866Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>當你使用 Chrome 瀏覽器時，是否曾留意過網址列出現的「<strong>不安全</strong>」？</p><p>尤其辛辛苦苦架好網站，甚至加上自訂域名，卻看到那幾個字，顯得格外刺眼——為什麼會出現這個呢？</p><p>這是因為 Google 鼓勵網站加上 SSL 憑證，那些能以 HTTPS 加密通訊協定存取的網站，就會加上綠色鎖頭字樣！甚至還列入了搜尋演算法的指標中，影響 SEO 排名。</p><p>話說到這裡，這個 SSL 憑證到底是什麼？</p><a id="more"></a><h2 id="SSL-Secure-Sockets-Layer（通訊安全協定）"><a href="#SSL-Secure-Sockets-Layer（通訊安全協定）" class="headerlink" title="SSL - Secure Sockets Layer（通訊安全協定）"></a>SSL - Secure Sockets Layer（通訊安全協定）</h2><p>SSL 的原文是 <strong>Secure Sockets Layer</strong>，聽起來好像很複雜，其實本意是為了保護使用者的個人資料、聯絡方式、付款資訊不被第三方所攔截的技術。</p><p><img src="https://i.imgur.com/DLeBOxF.png" alt=""></p><p>運作原理就是在瀏覽器拜訪網站時，會向對應的伺服器要求建立安全連線，這部分會協議使用的加密演算法或是密鑰交換演算法等機制，協議出一份密鑰來認證。</p><p>同時為了真正確保協議過程中的安全，除了協議的內容，伺服器還要回傳 <strong>CA（Certificate Authority，數位憑證）</strong>，這是第三方的認證，來讓使用者端確認不是冒用身分。</p><p>協議完成後，就可以按照協議進行加密、傳送資料了！經過加密的資料，即使第三方有心人士竊取到資料，也會因為缺少解密金鑰而無法得到正確訊息，只能看到亂碼。</p><p>在原本的 HTTP 協定中加入 SSL 憑證的通訊安全協定，就是 HTTPS 協定。</p><p><img src="https://i.imgur.com/0gXpLaO.png" alt=""></p><h2 id="用-Cloudflare-加上-SSL-憑證"><a href="#用-Cloudflare-加上-SSL-憑證" class="headerlink" title="用 Cloudflare 加上 SSL 憑證"></a>用 Cloudflare 加上 SSL 憑證</h2><p>我們可以使用 Cloudflare 的 DNS 代管服務，來免費使用 SSL 憑證。<br>只要將網域設為代管後，就能掛上 SSL 加密連線，擁有綠色鎖頭。</p><p>讓我們先申請 Cloudflare 服務吧！首先要讓 Cloudflare 來解析域名。</p><h3 id="申請-DNS-託管"><a href="#申請-DNS-託管" class="headerlink" title="申請 DNS 託管"></a>申請 DNS 託管</h3><p>註冊/登入後，點選 <strong>Add Site</strong>。</p><p><img src="https://i.imgur.com/h8u5R9K.png" alt=""></p><p>選擇免費方案，就可以使用 SSL 憑證囉。</p><p><img src="https://i.imgur.com/7J9KkvS.png" alt=""></p><p>解析後可能會有一些錯誤訊息，這部分通常與域名服務商中的 DNS 設定有關。<br>我的域名服務商是 <strong>Google Domains</strong>，後面會以 Google Domains 作為操作示範。</p><p>幾個常見錯誤訊息如下：</p><ul><li><p>An MX record was not found for your root domain. An MX record is required for mail to reach <code>@自訂域名</code> addresses.<br>如果有設定自訂電子郵件地址，自訂紀錄就必須設定 MX，沒設定可忽略。</p></li><li><p>An A, AAAA or CNAME record was not found for the www subdomain. The <code>自訂域名</code> subdomain will not resolve.<br>代表沒設定 A 或 CNAME，必須填齊。</p></li></ul><p><img src="https://i.imgur.com/AkGyFNQ.png" alt=""></p><p>由於我是使用 Github Pages，所以指向的 IP 是以下四組。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">185.199.108.153</span><br><span class="line">185.199.109.153</span><br><span class="line">185.199.110.153</span><br><span class="line">185.199.111.153</span><br></pre></td></tr></table></figure><h3 id="設定名稱伺服器"><a href="#設定名稱伺服器" class="headerlink" title="設定名稱伺服器"></a>設定名稱伺服器</h3><p>接下來要把域名服務商的名稱伺服器，改成<strong>使用自訂名稱伺服器</strong>。</p><p><img src="https://i.imgur.com/FWNNm2g.png" alt=""></p><p>填上 Cloudflare 所給的兩組名稱伺服器，儲存後回到 Cloudflare 去 Re-check。</p><p>更新可能要很久，過一段時間再回來確認吧。<br>生效後，就會看到出現啟用狀態，代表 DNS 託管設定完成。</p><p><img src="https://i.imgur.com/pCic5BS.png" alt=""></p><h3 id="啟用-SSL-憑證"><a href="#啟用-SSL-憑證" class="headerlink" title="啟用 SSL 憑證"></a>啟用 SSL 憑證</h3><p>接下來終於可以使用 SSL 憑證了！點開 <strong>SSL/TLS</strong> 來確認吧。</p><p><img src="https://i.imgur.com/faoEwGd.png" alt=""></p><p>Cloudflare 通常會自動使用 SSL 憑證，設定是 Fiexible，代表確實運作中，看見網址列出現鎖頭就完成了。</p><ul><li><strong>Off</strong><br>未啟用 SSL</li><li><strong>Flexible</strong><br>CloudFlare 會透過 HTTP 存取伺服器，再透過 HTTPS 跟使用者連線，所以使用者可以透過 HTTPS 連線到網站</li><li><strong>Full</strong><br>CloudFlare 會透過 HTTPS 存取伺服器，同時也透過 HTTPS 跟使用者連線</li><li><strong>Full (Strict)</strong><br>強制使用 HTTPS 連線，但 Cloudflare 會檢查第三方是不是信任憑證（不可自簽）</li></ul><p><img src="https://i.imgur.com/lZKA0k5.png" alt=""></p><h3 id="設定自動跳轉"><a href="#設定自動跳轉" class="headerlink" title="設定自動跳轉"></a>設定自動跳轉</h3><p>最後要確保網站的所有訪問都是基於 HTTPS 協定，所以要讓 HTTP 自動跳轉到 HTTPS。</p><p>點開 <strong>SSL/TLS</strong> 底下的 <strong>Edge Certificates</strong> 分頁，找到 <strong>Always Use HTTPS</strong> 並打開。</p><p><img src="https://i.imgur.com/GjEQVnW.png" alt=""></p><p>這樣即使使用者在網址列輸入的是 HTTP，也會自動跳轉囉！</p><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>現在網站擁有 SSL 憑證了，原理是透過握手技術（<strong>Handshake</strong>）以及<strong>公私鑰加密</strong>，來達成資料加密的連線。不僅是安全，對於 SEO 也有優勢。</p><p>這之中利用了 <strong>CloudFlare</strong> 代管 DNS，提供免費的 <strong>SSL 憑證服務</strong>。<br>事實上 CloudFlare 能做到的可不只這樣，光是免費方案就提供了基本的<strong>安全防護</strong>、<strong>網站加速</strong>等其他功能，日後也可按需求付費升級。</p><p>我自己比較常用到的是這些：</p><ul><li><strong>Analytics</strong> 以檢視網站分析</li><li><strong>Speed</strong> 啟用 <strong>Auto Minify</strong></li><li><strong>Page Rules</strong> 自訂頁面規則</li></ul><p>你的網站還沒有 SSL 憑證嗎？不如現在就試試看吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;當你使用 Chrome 瀏覽器時，是否曾留意過網址列出現的「&lt;strong&gt;不安全&lt;/strong&gt;」？&lt;/p&gt;
&lt;p&gt;尤其辛辛苦苦架好網站，甚至加上自訂域名，卻看到那幾個字，顯得格外刺眼——為什麼會出現這個呢？&lt;/p&gt;
&lt;p&gt;這是因為 Google 鼓勵網站加上 SSL 憑證，那些能以 HTTPS 加密通訊協定存取的網站，就會加上綠色鎖頭字樣！甚至還列入了搜尋演算法的指標中，影響 SEO 排名。&lt;/p&gt;
&lt;p&gt;話說到這裡，這個 SSL 憑證到底是什麼？&lt;/p&gt;
    
    </summary>
    
    
      <category term="技術心得" scheme="https://blog.weitw.net/categories/%E6%8A%80%E8%A1%93%E5%BF%83%E5%BE%97/"/>
    
    
      <category term="Cloudflare" scheme="https://blog.weitw.net/tags/Cloudflare/"/>
    
      <category term="SSL" scheme="https://blog.weitw.net/tags/SSL/"/>
    
      <category term="Google Domains" scheme="https://blog.weitw.net/tags/Google-Domains/"/>
    
  </entry>
  
  <entry>
    <title>Hexo + GitHub Actions 打造自動部署</title>
    <link href="https://blog.weitw.net/posts/350dd70b/"/>
    <id>https://blog.weitw.net/posts/350dd70b/</id>
    <published>2019-12-22T15:59:59.000Z</published>
    <updated>2019-12-27T17:27:41.862Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>這篇文章的出現，要從兩年前開始說起，那時候的我才剛開始摸 <a href="https://hexo.io/zh-tw/index.html">Hexo</a>。<br>當時的我比起其他平台，像是 Wordpress / Medium / Logdown 等等諸如此類，更喜歡 markdown 寫作方式，所以興致沖沖地架了個部落格。</p><p>但是很快地，過了大約一年左右便很少更新：<strong>為什麼會這樣呢？</strong><br>終歸一句當然還是懶啦。</p><p>主要是靜態網頁的佈署步驟太麻煩，必須滿足本地端有 Hexo 檔案的前提，我偏偏又喜歡用 <a href="https://hackmd.io/">HackMD</a> 撰寫，一來一往之間步驟太過繁複。</p><p>久而久之，這段時間我傾向於使用 HackMD 整理個人筆記，懶得發表技術文章到 blog 上。<br>——直到我注意到 GitHub 推出 <strong>CI/CD 服務</strong>，能幫助我解決這個麻煩！趁這個機會我打算順便打理 Hexo 架構，把菜鳥時期我搭建的部落格重新打掉，在 2020 前夕超進化！</p><a id="more"></a><h2 id="什麼是-Hexo"><a href="#什麼是-Hexo" class="headerlink" title="什麼是 Hexo"></a>什麼是 Hexo</h2><p>想進一步瞭解更多，可以看看中文的 <a href="https://hexo.io/zh-tw/docs/">Hexo官方文件</a>。</p><blockquote><p>  Hexo 是一個快速、簡單且強大的網誌框架。Hexo 使用 Markdown（或其他渲染引擎）解析您的文章，並在幾秒鐘內，透過漂亮的主題產生靜態檔案。</p></blockquote><p>Hexo 使用 Node.js 搭建，速度快且免費，操作也相對簡單，更是支持 Markdown ，也有不少第三方外掛系統。</p><h2 id="準備工作-for-Windows"><a href="#準備工作-for-Windows" class="headerlink" title="準備工作 for Windows"></a>準備工作 for Windows</h2><p>事前需要先安裝以下軟體</p><ul><li><a href="https://nodejs.org/en/">Node.js</a></li><li><a href="https://desktop.github.com/">Github</a><ul><li>當然你必須先擁有屬於自己的 github 帳號</li><li>登入 Github 之後，點選右上角 Create repository<br>Repository name 必須是 <code>github帳號.github.io</code> 並選擇 Public</li></ul></li></ul><p>安裝好上述軟體後，就可以打開 Shell 鍵入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>透過 npm 就可以順利完成 Hexo 的安裝了</p><h2 id="開始使用-Hexo"><a href="#開始使用-Hexo" class="headerlink" title="開始使用 Hexo"></a>開始使用 Hexo</h2><p>接下來，我們要進行初始化和安裝，在 Shell 鍵入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>跑完後，會在該資料夾底下新增所需要的檔案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure><p>等它跑完就可以開始寫新文章、架 blog 了，初步的建置就是如此簡單！</p><h2 id="Hexo-基本指令"><a href="#Hexo-基本指令" class="headerlink" title="Hexo 基本指令"></a>Hexo 基本指令</h2><h3 id="建立新文章"><a href="#建立新文章" class="headerlink" title="建立新文章"></a>建立新文章</h3><p>在 Shell 鍵入以下訊息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">"postName"</span>  <span class="comment"># 建立一個新的文章</span></span><br></pre></td></tr></table></figure><p>新文章的格式是 markdown，可以到 <code>source/_post/postName.md</code> 去修改</p><h3 id="預覽-blog"><a href="#預覽-blog" class="headerlink" title="預覽 blog"></a>預覽 blog</h3><p>在 Shell 鍵入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g <span class="comment"># (也可以打 hexo generate) 產生 blog</span></span><br><span class="line">hexo s <span class="comment"># (也可以打 hexo server)   讓 blog 可在 local 端檢視</span></span><br></pre></td></tr></table></figure><p>在 <code>http://localhost:4000</code> 就可以看見剛剛建好的 blog</p><h2 id="使用-Hexo-Deploy-部署"><a href="#使用-Hexo-Deploy-部署" class="headerlink" title="使用 Hexo Deploy 部署"></a>使用 Hexo Deploy 部署</h2><h3 id="安裝-hexo-deployer-git"><a href="#安裝-hexo-deployer-git" class="headerlink" title="安裝 hexo-deployer-git"></a>安裝 hexo-deployer-git</h3><p>在 Shell 鍵入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><h3 id="修改-config-yml"><a href="#修改-config-yml" class="headerlink" title="修改 _config.yml"></a>修改 _config.yml</h3><p>接下來打開資料夾中的 <code>_config.yml</code> 編輯 <code>deploy:</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: https://github.com/你的 github 帳號/你的專案名稱.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>完成設定以後，就可以發佈 blog 了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy <span class="comment"># (也可以打 hexo d) 發佈 blog</span></span><br></pre></td></tr></table></figure><p>發布之後，到專案的 <strong>Settings</strong> 啟用 <strong>GitHub Pages</strong><br><strong>Source</strong> 的欄位就選剛才填的 deploy branch</p><p><img src="https://i.imgur.com/wp4Qu8P.png" alt=""></p><p>等一段時間後，就會顯示啟用，就可以從 <code>http://github帳號.github.io</code> 連上 blog，完成初步工作！</p><p>到這個階段其實已經可以利用 <code>hexo</code> 基本指令在本地端架 blog 了，只是為了完成自動化部署，我又加入了 CI/CD 流程！</p><h2 id="使用-GitHub-Actions-實現-CI-CD"><a href="#使用-GitHub-Actions-實現-CI-CD" class="headerlink" title="使用 GitHub Actions 實現 CI/CD"></a>使用 GitHub Actions 實現 CI/CD</h2><h3 id="什麼是-CI-CD"><a href="#什麼是-CI-CD" class="headerlink" title="什麼是 CI/CD"></a>什麼是 CI/CD</h3><blockquote><p>CI（Continuous integration）為「持續性整合」，目的是讓專案能夠在每一次的變動中都能通過一些檢驗來確保專案品質。 CD（Continuous Deployment）則為「自動化部署」，讓專案能夠自動在每次變動後能以最新版本呈現。</p></blockquote><p>事實上在業界應用中，可做的多了，像是：環境建置、單元測試、日誌紀錄、產品部署，可以簡化開發流程。<br>而在 Hexo 的 blog 架設過程中，我們也能用它來達成自動部署！</p><p><strong>GitHub Actions</strong> 是由 GitHub 提供的 CI/CD 服務，用於在 GitHub 建置、測試、封裝、發佈或部署任何專案。並可藉此建置端對端（end-to-end）CI/CD 功能。</p><h3 id="建立-CI-CD-流程雛形"><a href="#建立-CI-CD-流程雛形" class="headerlink" title="建立 CI / CD 流程雛形"></a>建立 CI / CD 流程雛形</h3><p>Hexo 所提供的指令 <code>hexo generate</code> 其實是幫我們產生靜態網頁檔案，也就是 <code>public</code> 資料夾的內容。<br>同時 <code>hexo deploy</code> 則將 <code>public</code> 資料夾中的內容推送到 <code>_config.yml</code> 中指定的遠端專案的分支中，並 <strong>完全覆蓋</strong> 當下分支的已有內容。</p><p>因此我們的目的其實是要把這份運用 Hexo 框架的原始碼資料夾推送到 GitHub 的另一個專案分支上，並藉由 GitHub 所提供的 CI/CD 服務幫我們進行產生靜態網頁檔案，再推送到指定專案分支，也就是我們現在建立起 GitHub Pages 的專案上。</p><h3 id="把-Hexo-原始碼推送到-GitHub"><a href="#把-Hexo-原始碼推送到-GitHub" class="headerlink" title="把 Hexo 原始碼推送到 GitHub"></a>把 Hexo 原始碼推送到 GitHub</h3><p>首先要把 Hexo 真正的 source code 推送到 GitHub 上建立一個新專案。<br>將這個專案設為 <strong>Private</strong>，不公開他人瀏覽。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git add --all</span><br><span class="line">git commit -m &quot;First commit&quot;</span><br><span class="line">git remote add origin https:&#x2F;&#x2F;github.com&#x2F;你的 github 帳號&#x2F;新專案名稱.git</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><h3 id="建立-SSH-Key"><a href="#建立-SSH-Key" class="headerlink" title="建立 SSH Key"></a>建立 SSH Key</h3><p>在執行 Github Actions 的過程中，為了讓這段程式也可以把靜態網頁推送到原先我們所建立的專案上，必須建立一個 SSH Key 給它使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -f github-deploy-key <span class="comment"># 然後三次 Enter</span></span><br></pre></td></tr></table></figure><ul><li><p>原始碼專案<br>到 <strong>Setings</strong> 的 <strong>Secrets</strong> 去 Add a new secret</p><ul><li>Name 輸入 <code>HEXO_DEPLOY_PRI</code></li><li>Value 填上私鑰 <code>github-actions-deploy</code> 的內容</li></ul></li><li><p>靜態網頁專案<br>到 <strong>Setings</strong> 的 <strong>Deploy keys</strong></p><ul><li>Title 輸入 <code>HEXO_DEPLOY_PUB</code></li><li>Key 填上公鑰 <code>github-actions-deploy.pub</code> 的內容</li><li>勾選 Allow write access</li></ul></li></ul><h3 id="修改-config-yml-1"><a href="#修改-config-yml-1" class="headerlink" title="修改 _config.yml"></a>修改 _config.yml</h3><p>再打開資料夾中的 <code>_config.yml</code> 編輯 <code>deploy:</code>，要改成 ssh 連線才可以順利部署</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: git@github.com:你的github帳號/你的靜態網頁專案名稱.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>記得要 commit 後推送到專案上</p><h3 id="設定-GitHub-Actions"><a href="#設定-GitHub-Actions" class="headerlink" title="設定 GitHub Actions"></a>設定 GitHub Actions</h3><p>回到原始碼專案，到 <strong>Actions</strong> 右上角選擇 <strong>Set up a workflow yourself</strong></p><p>我的 <code>main.yml</code> 設定如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">Blog</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span> <span class="string">[push]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/checkout@v1</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Use</span> <span class="string">Node.js</span> <span class="number">10.</span><span class="string">x</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">node-version:</span> <span class="string">"10.x"</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Hexo</span> <span class="string">env</span></span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">        <span class="attr">HEXO_DEPLOY_PRI:</span> <span class="string">$&#123;&#123;secrets.HEXO_DEPLOY_PRI&#125;&#125;</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">        <span class="comment"># set up private key for deploy</span></span><br><span class="line">        <span class="string">mkdir</span> <span class="string">-p</span> <span class="string">~/.ssh/</span></span><br><span class="line">        <span class="string">echo</span> <span class="string">"$HEXO_DEPLOY_PRI"</span> <span class="string">&gt;</span> <span class="string">~/.ssh/id_rsa</span></span><br><span class="line">        <span class="string">chmod</span> <span class="number">600</span> <span class="string">~/.ssh/id_rsa</span></span><br><span class="line">        <span class="string">ssh-keyscan</span> <span class="string">github.com</span> <span class="string">&gt;&gt;</span> <span class="string">~/.ssh/known_hosts</span></span><br><span class="line">        <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.name</span> <span class="string">'使用者帳號'</span></span><br><span class="line">        <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.email</span> <span class="string">'使用者信箱'</span></span><br><span class="line">        <span class="comment"># install dependencies</span></span><br><span class="line">        <span class="string">npm</span> <span class="string">i</span> <span class="string">-g</span> <span class="string">hexo-cli</span></span><br><span class="line">        <span class="string">npm</span> <span class="string">i</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">        <span class="comment"># generate and depoly</span></span><br><span class="line">        <span class="string">hexo</span> <span class="string">g</span> <span class="string">-d</span></span><br></pre></td></tr></table></figure><h3 id="確認-workflows-生效"><a href="#確認-workflows-生效" class="headerlink" title="確認 workflows 生效"></a>確認 workflows 生效</h3><p>把 <code>main.yml</code> 推上 <code>workflows/</code> 後，再一次回到 Actions 確認</p><p><img src="https://i.imgur.com/BVXrSPn.png" alt=""></p><p>本地端檔案也要記得同步 <code>main.yml</code> 建立時推上去的 commit</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote update</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure><h3 id="blog-變更生效"><a href="#blog-變更生效" class="headerlink" title="blog 變更生效"></a>blog 變更生效</h3><p>每次要更動 blog 內容，像是發文或更改佈景等操作都要記得推上去</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;變更內容&quot;</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>Github Actions 就會幫我們自動執行後續動作</p><h3 id="備份原始碼"><a href="#備份原始碼" class="headerlink" title="備份原始碼"></a>備份原始碼</h3><p>既然都把原始碼 git 上去了，以後如果要在其他電腦架 blog，只需要</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:你的github帳號&#x2F;你的原始碼專案名稱.git</span><br><span class="line">cd 你的原始碼專案名稱</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>順手完成了備份動作，是不是一石二鳥呢！</p><h3 id="線上發文"><a href="#線上發文" class="headerlink" title="線上發文"></a>線上發文</h3><p>現在讓我們試著用 GitHub 直接線上發文<br>到專案原始碼底下的 <code>source/_posts</code> 選擇右上角 <strong>Create new file</strong></p><p><img src="https://i.imgur.com/snIwAWC.png" alt=""></p><p><code>file name</code> 即為<code>文章標題.md</code>，內容要調整成 hexo 文章格式</p><p><img src="https://i.imgur.com/aB8fkjX.png" alt=""></p><p>然後選擇 <strong>Commit new file</strong><br>如此以來就真正實現我想要的線上發布功能了！大功告成！</p><h2 id="踩坑經歷"><a href="#踩坑經歷" class="headerlink" title="踩坑經歷"></a>踩坑經歷</h2><h3 id="更改佈景主題"><a href="#更改佈景主題" class="headerlink" title="更改佈景主題"></a>更改佈景主題</h3><p>在 <a href="https://hexo.io/themes/">Hexo Themes</a> 中尋找你喜歡的佈景主題並保存到 <code>themes</code> 下<br>之後打開 <code>_config.yml</code>，找到 <code>theme:</code> 修改成佈景名稱，也就是資料夾的對應名稱</p><p>如果是 git clone 下來的主題<br>為了得以順利執行 actions，必須先將 <code>themes</code> 底下的 <code>/.git</code> 刪除，然後加入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .\themes\主題名稱\</span><br><span class="line">git add -f .\themes\主題名稱\_config.yml</span><br></pre></td></tr></table></figure><h3 id="設定自定義域名"><a href="#設定自定義域名" class="headerlink" title="設定自定義域名"></a>設定自定義域名</h3><p>重點同樣是域名服務商的設定，設定好之後記得要在 <code>source</code> 底下保存一個 <code>CNAME</code> 推上去<br>才不會每次 push 後自訂域名設定都被覆蓋</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;這篇文章的出現，要從兩年前開始說起，那時候的我才剛開始摸 &lt;a href=&quot;https://hexo.io/zh-tw/index.html&quot;&gt;Hexo&lt;/a&gt;。&lt;br&gt;當時的我比起其他平台，像是 Wordpress / Medium / Logdown 等等諸如此類，更喜歡 markdown 寫作方式，所以興致沖沖地架了個部落格。&lt;/p&gt;
&lt;p&gt;但是很快地，過了大約一年左右便很少更新：&lt;strong&gt;為什麼會這樣呢？&lt;/strong&gt;&lt;br&gt;終歸一句當然還是懶啦。&lt;/p&gt;
&lt;p&gt;主要是靜態網頁的佈署步驟太麻煩，必須滿足本地端有 Hexo 檔案的前提，我偏偏又喜歡用 &lt;a href=&quot;https://hackmd.io/&quot;&gt;HackMD&lt;/a&gt; 撰寫，一來一往之間步驟太過繁複。&lt;/p&gt;
&lt;p&gt;久而久之，這段時間我傾向於使用 HackMD 整理個人筆記，懶得發表技術文章到 blog 上。&lt;br&gt;——直到我注意到 GitHub 推出 &lt;strong&gt;CI/CD 服務&lt;/strong&gt;，能幫助我解決這個麻煩！趁這個機會我打算順便打理 Hexo 架構，把菜鳥時期我搭建的部落格重新打掉，在 2020 前夕超進化！&lt;/p&gt;
    
    </summary>
    
    
      <category term="技術心得" scheme="https://blog.weitw.net/categories/%E6%8A%80%E8%A1%93%E5%BF%83%E5%BE%97/"/>
    
    
      <category term="Hexo" scheme="https://blog.weitw.net/tags/Hexo/"/>
    
      <category term="Github" scheme="https://blog.weitw.net/tags/Github/"/>
    
      <category term="CI/CD" scheme="https://blog.weitw.net/tags/CI-CD/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js 新手上路</title>
    <link href="https://blog.weitw.net/posts/7694b685/"/>
    <id>https://blog.weitw.net/posts/7694b685/</id>
    <published>2018-02-03T15:06:49.000Z</published>
    <updated>2019-12-27T17:27:41.866Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在開始學習今天的主題之前，我們要來先討論一下：<strong>為什麼要學框架（Framework）？</strong><br>因為很潮正夯特流行嗎？因為業界好找工作嗎？又有什麼是只用 jQuery 辦不到的事情嗎？</p><p>簡單來說，<strong>jQuery</strong> 是<strong>以 DOM 元素來觸發功能</strong>，能幫助我們更簡單的實現網頁上的資料互動及事件處理方法，同時也簡化了許多 AJAX 的操作方法，是設計動畫效果的絕佳利器。</p><p>然而 <strong>框架（Framework）</strong> 包括你聽過的三神獸 <strong>Vue</strong>, <strong>Angular</strong>, <strong>React</strong>，都是<strong>以資料來驅動功能</strong>，適合用來撰寫一些以資料為主體的網頁以及 SPA，能幫助我們更加簡潔地去處理資料邏輯。</p><a id="more"></a><h2 id="進入-Vue-js-世界"><a href="#進入-Vue-js-世界" class="headerlink" title="進入 Vue.js 世界"></a>進入 Vue.js 世界</h2><p>讓我們先寫一個簡單的  <strong>Vue 建構式（Vue Vonstructor）</strong> 來建立 view model ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'.app'</span>, <span class="comment">// 要綁定的 DOM element，即作用範圍</span></span><br><span class="line">  data: &#123; <span class="comment">// 資料綁定</span></span><br><span class="line">  msg: <span class="string">'Hello World!'</span>, </span><br><span class="line">  users: [&#123;<span class="attr">name</span>: <span class="string">'Tom'</span>, <span class="attr">gender</span>: <span class="string">'male'</span>, <span class="attr">age</span>: <span class="number">20</span>&#125;,&#123;<span class="attr">name</span>: <span class="string">'Alice'</span>, <span class="attr">gender</span>: <span class="string">'female'</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;] ,</span><br><span class="line">        isActive: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;&#125;, <span class="comment">// 當資料改變時，對應更新的變動值</span></span><br><span class="line">  methods: &#123;&#125; <span class="comment">// 可以定義在元件或樣板內使用的 method</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="資料綁定-Data-Binding"><a href="#資料綁定-Data-Binding" class="headerlink" title="資料綁定 Data Binding"></a>資料綁定 Data Binding</h2><h4 id="data-的作用"><a href="#data-的作用" class="headerlink" title="data 的作用"></a>data 的作用</h4><ul><li>儲存元件內部狀態或資料</li><li>和 v-model 合作實現雙向綁定</li></ul><p>利用 Mustache 的雙括號語法以及 <strong>模板語法</strong> 可以直接將 data 的值置入</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h4><p>雙括號語法不能直接寫入 html 的屬性之中，需使用 <code>v-bind</code> 語法作屬性綁定，縮寫為 <code>:</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"title"</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"userList"</span> <span class="attr">:class</span>=<span class="string">"&#123; active: isActive &#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"userItem"</span> <span class="attr">v-for</span>=<span class="string">"item in users"</span> <span class="attr">:key</span>=<span class="string">"item.id"</span>&gt;</span>&#123;&#123;item.name&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="其他模板語法"><a href="#其他模板語法" class="headerlink" title="其他模板語法"></a>其他模板語法</h4><ul><li><strong>v-if</strong> , <strong>v-else-if</strong>, <strong>v-else</strong><br>形如 <code>v-if=&quot;boolean&quot;</code> ,  <code>v-else-if=&quot;boolean&quot;</code>  ,  <code>v-else</code><br>類似 <a href="http://handlebarsjs.com/">Handlebars.js</a> 中的 &#123;&#123;#if boolean&#125;&#125; ,  &#123;&#123;else&#125;&#125;</li><li><strong>v-show</strong><br>形如 <code>v-show=&quot;boolean&quot;</code><br>類似 <code>v-if</code>，不過會保留 DOM 元素本身，只是改變 <code>display: none</code> </li><li><strong>v-for</strong><br>形如 <code>v-for=&quot;item in array&quot;</code><br>類似 <a href="http://handlebarsjs.com/">Handlebars.js</a> 中的 &#123;&#123;#each item&#125;&#125;</li></ul><h2 id="屬性計算-Computed-Propertries"><a href="#屬性計算-Computed-Propertries" class="headerlink" title="屬性計算 Computed Propertries"></a>屬性計算 Computed Propertries</h2><p>我們可以直接利用 <strong>computed</strong> 來幫助我們 <strong>處理雙括號表達式的資料邏輯</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;  <span class="comment">// 當資料改變時，對應更新的變動值</span></span><br><span class="line">  userNum: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> users.length;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><strong>computed</strong> 有以下特點</p><ul><li>function 本身無法帶入外部參數</li><li>具有資料緩存的功能，不會每次都重新渲染<br>當使用的 data 中的對應值變動，<strong>computed</strong> 裡的值<strong>才會自動更新</strong></li></ul><h2 id="Methods-與事件處理"><a href="#Methods-與事件處理" class="headerlink" title="Methods 與事件處理"></a>Methods 與事件處理</h2><h4 id="methods"><a href="#methods" class="headerlink" title="methods"></a>methods</h4><p>我們可以在 <strong>methods</strong> 裡面定義可被 vue 物件呼叫的 function</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123; <span class="comment">// 可以定義在元件或樣板內使用的 method</span></span><br><span class="line">  addFollow: <span class="function"><span class="keyword">function</span>(<span class="params">user</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>而在 function 裡呼叫的 this 會自動綁定為呼叫這個 function 的物件<br>同時必須注意的是，也就<strong>不能使用 ES6 中的箭頭函數</strong>來定義 method function</p><h4 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h4><p>使用 <code>v-on</code> 語法作事件處理的綁定，縮寫為 <code>@</code> </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"userList"</span> <span class="attr">:class</span>=<span class="string">"&#123; active: isActive &#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"userItem"</span> <span class="attr">v-for</span>=<span class="string">"item in users"</span> <span class="attr">:key</span>=<span class="string">"item.id"</span>&gt;</span>&#123;&#123;item.name&#125;&#125;</span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">void</span> @<span class="attr">click</span>=<span class="string">"setFollow(item)"</span>&gt;</span>Follow<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>再去呼叫我們在 <strong>methods</strong> 中所定義的 function</p><h2 id="雙向綁定"><a href="#雙向綁定" class="headerlink" title="雙向綁定"></a>雙向綁定</h2><h4 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h4><p><code>v-model</code> 可以幫助我們實現雙向綁定，也就是說<strong>去動態同步更改 data 的資料</strong>，在表單呈現上特別好用<br>限用於<code>&lt;input&gt;</code>、<code>&lt;select&gt;</code>和<code>&lt;textarea&gt;</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"msg"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Todos-with-Vue-js"><a href="#Todos-with-Vue-js" class="headerlink" title="Todos with Vue.js"></a>Todos with Vue.js</h2><p>利用前面所提及的各種方法，實作出一個簡單的 todo list</p><iframe height='400' scrolling='no' title='todos with vue.js' src='//codepen.io/veru/embed/JMMXxQ/?height=400&theme-id=0&default-tab=js,result&embed-version=2' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;'>See the Pen <a href='https://codepen.io/veru/pen/JMMXxQ/'>todos with vue.js</a> by Veru (<a href='https://codepen.io/veru'>@veru</a>) on <a href='https://codepen.io'>CodePen</a>.</iframe><ul><li>實作功能<ul><li>可新增/刪除 todo</li><li>可將 todo 標示完成</li><li>顯示未完成的 todo 數量</li><li>可切換不同分頁：全部/未完成/已完成</li><li>快捷鍵：完成所有 todo/刪除已完成 todo</li></ul></li></ul><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul><li><a href="https://cn.vuejs.org/v2/guide/">Vue.js 官方文件</a></li><li><a href="https://www.slideshare.net/kurotanshi/vuejs-62131923">第一次用 Vue.js 就愛上</a></li><li><a href="https://cythilya.github.io/2017/05/21/vue-study-note/">Summer 的 Vue.js 學習筆記總整理</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在開始學習今天的主題之前，我們要來先討論一下：&lt;strong&gt;為什麼要學框架（Framework）？&lt;/strong&gt;&lt;br&gt;因為很潮正夯特流行嗎？因為業界好找工作嗎？又有什麼是只用 jQuery 辦不到的事情嗎？&lt;/p&gt;
&lt;p&gt;簡單來說，&lt;strong&gt;jQuery&lt;/strong&gt; 是&lt;strong&gt;以 DOM 元素來觸發功能&lt;/strong&gt;，能幫助我們更簡單的實現網頁上的資料互動及事件處理方法，同時也簡化了許多 AJAX 的操作方法，是設計動畫效果的絕佳利器。&lt;/p&gt;
&lt;p&gt;然而 &lt;strong&gt;框架（Framework）&lt;/strong&gt; 包括你聽過的三神獸 &lt;strong&gt;Vue&lt;/strong&gt;, &lt;strong&gt;Angular&lt;/strong&gt;, &lt;strong&gt;React&lt;/strong&gt;，都是&lt;strong&gt;以資料來驅動功能&lt;/strong&gt;，適合用來撰寫一些以資料為主體的網頁以及 SPA，能幫助我們更加簡潔地去處理資料邏輯。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技術心得" scheme="https://blog.weitw.net/categories/%E6%8A%80%E8%A1%93%E5%BF%83%E5%BE%97/"/>
    
    
      <category term="Vue" scheme="https://blog.weitw.net/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>淺談 AMP (Accelerated Mobile Pages)</title>
    <link href="https://blog.weitw.net/posts/dc7de635/"/>
    <id>https://blog.weitw.net/posts/dc7de635/</id>
    <published>2017-12-10T02:51:00.000Z</published>
    <updated>2019-12-27T17:27:41.866Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>網站速度、內容品質，這些都是 SEO的排名因素，同時也跟用戶體驗息息相關。而 Google 在<a href="https://googleblog.blogspot.tw/2015/10/introducing-accelerated-mobile-pages.html">2015 年正式發佈</a>其獨有的 <strong>AMP</strong> 框架，中文為 <strong>加速版行動網頁</strong> 。</p><p>AMP是 Google 獨有的網頁框架，用來使行動裝置網頁能快速載入。如果你有架設 AMP框架，促進使用者體驗優化，也許會讓該頁面的 rankng 提升 ，同時這個框架也能夠非常有效的提升用戶體驗，未來 AMP將有可能會越來越被重視、且也有可能在搜尋排名中佔有更強的影響力。</p><p><a href="https://www.ampproject.org/docs/tutorials/create">Google 官方網站</a>上也一步步演示了要如何架設 AMP 網站，主要可分為三大部分</p><ul><li>AMP HTML</li><li>AMP JS</li><li>AMP Cache</li></ul><a id="more"></a><h2 id="AMP-HTML"><a href="#AMP-HTML" class="headerlink" title="AMP HTML"></a>AMP HTML</h2><p>必須按照其規格撰寫：</p><ul><li>以 <code>&lt;!doctype html&gt;</code> 開頭</li><li>其中第一個  tag 須為 <code>&lt;html ⚡&gt;</code> 或 <code>&lt;html amp&gt;</code> 表示為 AMP 網頁</li><li>必須包含 <code>&lt;head&gt;</code> 與 <code>&lt;body&gt;</code></li><li>在 <code>&lt;head&gt;</code> 內必須以 <code>&lt;meta charset=&quot;utf-8&quot;&gt;</code> 作為第一個 tag</li><li>在 <code>&lt;head&gt;</code> 內必須包含 <code>&lt;script async src=&quot;https://cdn.ampproject.org/v0.js&quot;&gt;&lt;/script&gt;</code> tag 以引入 AMP JS</li><li>在 <code>&lt;head&gt;</code> 內必須包含 <code>&lt;link rel=&quot;canonical&quot; href=&quot;$SOME_URL&quot;&gt;</code> 其中 <code>$SOME_URL</code> 指向原本的非 AMP 網頁</li><li>在 <code>&lt;head&gt;</code> 內必須包含 <code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,minimum-scale=1&quot;&gt;</code> 並且建議加入 <code>initial-scale=1</code></li><li>在 <code>&lt;head&gt;</code> 內必須包含 <a href="https://www.ampproject.org/docs/reference/spec/amp-boilerplate">AMP Boilerplate Code</a></li></ul><p>一個頁面可使用唯一一個 <code>&lt;style amp-custom&gt;</code> tag 來自訂 style，然而有些 css 屬性是禁用的，但更加上了一些額外的屬性幫助我們排版，可見<a href="https://www.ampproject.org/docs/guides/responsive_amp">相關規範</a>。</p><p>而 HTML tags 也多以 AMP HTML tags 予以取代，像是 <code>&lt;img&gt;</code> 以 <code>&lt;amp-img&gt;</code> 替代，等等<a href="https://www.ampproject.org/zh_cn/docs/reference/components">其他 component</a>，這部分在下個段落會再細談。</p><h2 id="AMP-JS"><a href="#AMP-JS" class="headerlink" title="AMP JS"></a>AMP JS</h2><p>為了有效管理資源載入並提供客製化標籤，所以僅能使用 AMP 的元件，不允許使用任何第三方的外連 js file 或是 inline script，也就是說你只能使用 AMP 規範提供的 <a href="https://www.ampproject.org/zh_cn/docs/reference/components">Component 元件</a> 去完成網頁的行為，或者 iframe 一個非 AMP 頁面進來。</p><p> AMP 規範所提供 Component 大略可分為以下數類：</p><ul><li><a href="https://www.ampproject.org/docs/reference/components#ads-and-analytics">Ads &amp; analytics</a></li><li><a href="https://www.ampproject.org/docs/reference/components#dynamic-content">Dynamic content</a></li><li><a href="https://www.ampproject.org/docs/reference/components#layout">Layout</a></li><li><a href="https://www.ampproject.org/docs/reference/components#media">Media</a></li><li><a href="https://www.ampproject.org/docs/reference/components#presentation">Presentation</a></li><li><a href="https://www.ampproject.org/docs/reference/components#social">Social</a></li></ul><h2 id="AMP-Cache"><a href="#AMP-Cache" class="headerlink" title="AMP Cache"></a>AMP Cache</h2><p>Google AMP Cache 會驗證你的網站是否為 AMP 網頁，如果網站符合其規範，Search Result 便會出現 AMP Cache 的結果，提供快取好的 AMP HTML 網頁。</p><p>同時這個搜尋結果會出現在一個新的區塊 <strong>Top Stories 版位</strong>，只有支援 AMP 的網頁才會出現，所以支援 AMP 網站等同於讓你的網頁多了一次機會出現在 Google search result 。</p><p><img src="http://www.thesempost.com/wp-content/uploads/2016/02/amp-demo2-576x1024.png" alt=""></p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>AMP 最大優點當然就是頁面的加載速度的顯著提升，在 Google 的搜尋結果更會多出一個 Top Stories 版位。</p><p>然而其諸多限制也帶來一些困擾，例如廣告投放、外站圖源、用戶登入問題，這些都只能依賴 AMP 規範提供的 Component 去完成，當然也不能設計一些太過複雜的介面。基於這些限制，開發者是否要引入該框架技術，就勢必得再多加思量了。</p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul><li><a href="https://blog.lalacube.com/archives/2101/accelerated-mobile-pages-amp-%E5%AF%A6%E6%88%B0%E5%AE%88%E5%89%87">Accelerated Mobile Pages (AMP) 實戰守則</a></li><li><a href="http://tedshd.logdown.com/posts/1460247-amp-accelerated-mobile-pages">AMP - Accelerated Mobile Pages 研究筆記</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;網站速度、內容品質，這些都是 SEO的排名因素，同時也跟用戶體驗息息相關。而 Google 在&lt;a href=&quot;https://googleblog.blogspot.tw/2015/10/introducing-accelerated-mobile-pages.html&quot;&gt;2015 年正式發佈&lt;/a&gt;其獨有的 &lt;strong&gt;AMP&lt;/strong&gt; 框架，中文為 &lt;strong&gt;加速版行動網頁&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;AMP是 Google 獨有的網頁框架，用來使行動裝置網頁能快速載入。如果你有架設 AMP框架，促進使用者體驗優化，也許會讓該頁面的 rankng 提升 ，同時這個框架也能夠非常有效的提升用戶體驗，未來 AMP將有可能會越來越被重視、且也有可能在搜尋排名中佔有更強的影響力。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.ampproject.org/docs/tutorials/create&quot;&gt;Google 官方網站&lt;/a&gt;上也一步步演示了要如何架設 AMP 網站，主要可分為三大部分&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AMP HTML&lt;/li&gt;
&lt;li&gt;AMP JS&lt;/li&gt;
&lt;li&gt;AMP Cache&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="技術心得" scheme="https://blog.weitw.net/categories/%E6%8A%80%E8%A1%93%E5%BF%83%E5%BE%97/"/>
    
    
      <category term="AMP" scheme="https://blog.weitw.net/tags/AMP/"/>
    
      <category term="SEO" scheme="https://blog.weitw.net/tags/SEO/"/>
    
  </entry>
  
  <entry>
    <title>善用 Rebase 的 Git 工作流程</title>
    <link href="https://blog.weitw.net/posts/9d63e457/"/>
    <id>https://blog.weitw.net/posts/9d63e457/</id>
    <published>2017-11-01T02:53:37.000Z</published>
    <updated>2019-12-27T17:27:41.866Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>筆記一下工作上慣用的 Git 工作流程，也大略提及一下 Merge 和 Rebase 的差異。</p><h2 id="分支的合併"><a href="#分支的合併" class="headerlink" title="分支的合併"></a>分支的合併</h2><p>完成作業的 Topic 分支，最終都會合併到 Integration 分支。<br>合併分支有兩種方法：使用 <strong>merge</strong> 或 <strong>rebase</strong>。<br>兩者都是合併歷史記錄，但是根據使用的方法合併後的分支歷史記錄有很大的差別。</p><p><img src="https://i.imgur.com/MucvWQq.png" alt=""></p><a id="more"></a><h3 id="Merge"><a href="#Merge" class="headerlink" title="Merge"></a>Merge</h3><p>修改內容的歷史記錄會維持原狀，但是合併後的歷史紀錄會變得更複雜。<br><img src="https://i.imgur.com/fZnV9YR.png" alt=""></p><p>Git 在做 merge 時，會自動判斷現在的狀況是否適合是使用 <strong>fast-forward</strong>，或是我們可以透過加上 <code>--ff</code> 或是 <code>--no-ff</code> 來強制設定是否使用 fast-forward，差別如下：<br><img src="https://cdn-images-1.medium.com/max/800/1*SjSWhbwhPqFUTlPL8IV2mg.png" alt=""></p><p><code>--no-ff</code> 會多出一個 merge commit，而 <code>--ff</code> 會直接視為 master 分支上多出的 commit。<br>可視需求決定要使用哪種。</p><h3 id="Rebase"><a href="#Rebase" class="headerlink" title="Rebase"></a>Rebase</h3><p>修改內容的歷史記錄會接在要合併的分支後面，合併後的歷史記錄會比較清楚簡單，但是，會比使用 merge 更容易發生衝突。<br><img src="https://i.imgur.com/XXoH6Nr.png" alt=""></p><p><img src="https://i.imgur.com/8NqcY1V.png" alt=""></p><h2 id="Git-工作流程"><a href="#Git-工作流程" class="headerlink" title="Git 工作流程"></a>Git 工作流程</h2><p>如果我們要將 feature branch 合併進 master</p><ul><li><p>先切換到 feature branch，update 之後把遠端的 master 分支 rebase 進來<br><code>git checkout branch-name</code><br><code>git remote update</code><br><code>git rebase origin/master</code></p></li><li><p>切換到本地 master，當然要先確認本地 master 與遠端同步<br><code>git checkout master</code><br><code>git merge --ff origin/master</code></p></li><li><p>把 feature branch 給 merge 進來 master，同時要保留新增功能用的commit<br><code>git merge --no-ff branch-name</code></p></li><li><p>將本地 master 推上遠端<br><code>git push origin master</code></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;筆記一下工作上慣用的 Git 工作流程，也大略提及一下 Merge 和 Rebase 的差異。&lt;/p&gt;
&lt;h2 id=&quot;分支的合併&quot;&gt;&lt;a href=&quot;#分支的合併&quot; class=&quot;headerlink&quot; title=&quot;分支的合併&quot;&gt;&lt;/a&gt;分支的合併&lt;/h2&gt;&lt;p&gt;完成作業的 Topic 分支，最終都會合併到 Integration 分支。&lt;br&gt;合併分支有兩種方法：使用 &lt;strong&gt;merge&lt;/strong&gt; 或 &lt;strong&gt;rebase&lt;/strong&gt;。&lt;br&gt;兩者都是合併歷史記錄，但是根據使用的方法合併後的分支歷史記錄有很大的差別。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/MucvWQq.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="技術心得" scheme="https://blog.weitw.net/categories/%E6%8A%80%E8%A1%93%E5%BF%83%E5%BE%97/"/>
    
    
      <category term="Git" scheme="https://blog.weitw.net/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>資工系學士畢業新鮮人的自白</title>
    <link href="https://blog.weitw.net/posts/cb4a7f47/"/>
    <id>https://blog.weitw.net/posts/cb4a7f47/</id>
    <published>2017-10-19T04:58:02.000Z</published>
    <updated>2019-12-27T17:27:41.866Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>  當初應屆推本校資工所都沒上<br>  我很煩惱是不是該繼續往資工這條路走 – by young60509</p></blockquote><p>上週在批踢踢軟體版看到網友  young60509 發表的文章，<a href="https://www.ptt.cc/bbs/Soft_Job/M.1507876000.A.433.html">[請益] 該不該往資工走下去…</a> 作為同屆畢業生我看了也難免有感而發。</p><p>這篇文章並不會告訴大家，我在資工系修過什麼課、做了什麼事、遇到什麼人、學到什麼樣的東西，主要是想說說就讀資工系的我，甫畢業之初的一些看法。</p><a id="more"></a><h2 id="關於研究所或就業"><a href="#關於研究所或就業" class="headerlink" title="關於研究所或就業"></a>關於研究所或就業</h2><p>應該很多人畢業之後都會考慮要不要繼續往研究所進修，或是乾脆地投入職場。雖然我在校內也看過許多不假思索、二話不說就直接推甄研究所的人，你問他日後要往哪個領域走，選這個領域跟你日後職涯規劃有什麼關聯，他可能也回答不出所以然，不過我還是鼓勵大家在校時期多發掘自己的興趣。</p><p>瞭解自己的興趣，你才能更加具體去考量自己的職涯規劃。<br>如果想做<strong>演算法</strong>或<strong>圖學</strong>等偏重理論的領域，那當然要唸研究所。但如果你是想要走強調業界實務應用的領域，像是網頁工程師好了，那就要想一想是要做<strong>應用系統研究</strong>、<strong>使用者經驗</strong>還是別的什麼相關領域，才能對你的職涯規劃有幫助。</p><p>事實上，我看到的學長姐還是有很大部分畢業之後的職位與在校研究領域完全無關的，擠到台G店/發哥/紅茶店等等電子大廠居多。當然，我一點也不否定向錢看齊的想法，只是如此一來相當於在研究所的經驗變成一種純粹的職前訓練，訓練吸收知識跟解決問題的邏輯能力，但你的研究本身卻不見得能幫助掌握日後工作的相關技術，這是比較可惜的一點。</p><p>另外作為應屆畢業生，我也驗證一下<strong>校內推甄資工所要成績30%會不會上</strong>這個說法，答案是<strong>不一定</strong>，3X% 落榜的大有人在，而更加具體來說：<strong>更加注重業外表現</strong>，只有成績達標是有些勉強的。</p><h2 id="關於自學能力以及興趣"><a href="#關於自學能力以及興趣" class="headerlink" title="關於自學能力以及興趣"></a>關於自學能力以及興趣</h2><p><a href="https://www.ptt.cc/bbs/Soft_Job/M.1507876000.A.433.html">[請益] 該不該往資工走下去…</a>  這篇文章中樓主自己提到覺得自學能力差，不適合往資工領域發展，我認為更加精確的說法是：<strong>自主學習程式語言差</strong>。</p><p>無論就讀研究所或是直接就業，求財求生存的能力都跟你該領域的自學能力脫不了關係。這又回到了上面提到的興趣問題，如果在大學時期其實就能找到自己的興趣，並且在相關技術鑽研、做點 side project，我覺得是非常很有幫助的。也許你當時的興趣在日後無法學以致用，但以這份熱情去推動自身能力還是相當管用的。</p><blockquote><p>  ku399999: 學得慢又如何 是不是真慢都不知道 人生是長跑 持續學習努力絕對強過一狗票人</p></blockquote><p>原文中網友 ku399999 這句話我也相當認同。自學這件事情不管是不是要走軟體業，都會一輩子跟著你。這不是難不難的問題，只是你願不願意花心力去適應而已。不怕做不好，先做再說吧！</p><p>最後的最後，想記錄一句我最近也很喜歡的話。</p><blockquote><p>  “I’m a slow walker, but I never walk backwards.” - Abragam Lincoln</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;  當初應屆推本校資工所都沒上&lt;br&gt;  我很煩惱是不是該繼續往資工這條路走 – by young60509&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上週在批踢踢軟體版看到網友  young60509 發表的文章，&lt;a href=&quot;https://www.ptt.cc/bbs/Soft_Job/M.1507876000.A.433.html&quot;&gt;[請益] 該不該往資工走下去…&lt;/a&gt; 作為同屆畢業生我看了也難免有感而發。&lt;/p&gt;
&lt;p&gt;這篇文章並不會告訴大家，我在資工系修過什麼課、做了什麼事、遇到什麼人、學到什麼樣的東西，主要是想說說就讀資工系的我，甫畢業之初的一些看法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="生活紀錄" scheme="https://blog.weitw.net/categories/%E7%94%9F%E6%B4%BB%E7%B4%80%E9%8C%84/"/>
    
    
      <category term="NCTUCS" scheme="https://blog.weitw.net/tags/NCTUCS/"/>
    
  </entry>
  
  <entry>
    <title>我在社群網路公司實習的日子</title>
    <link href="https://blog.weitw.net/posts/20d7c148/"/>
    <id>https://blog.weitw.net/posts/20d7c148/</id>
    <published>2017-09-24T11:30:00.000Z</published>
    <updated>2019-12-27T17:27:41.866Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今年四月，我投遞出人生的第一份履歷。</p><p>我使用該公司的社群網路服務已有近七年之久，於是當他們釋出前端工程師的實習職位，考慮不過半天、回過神來我已將履歷投至對方信箱——也很幸運地，在經過篩選與面試後，我獲得了暑期實習的合作機會。</p><p>經過一段時間沈澱之後，我想我是該好好寫篇文章，分享我在短短兩個月的實習過程之中的所見所學。</p><a id="more"></a><h2 id="想像與現實"><a href="#想像與現實" class="headerlink" title="想像與現實"></a>想像與現實</h2><blockquote><p>  我所期望的實習型態是圍繞著特定專案的核心概念，再以實踐專案中的每個功能、使用者經驗優化為目標，去摸索與學習。</p><p>  學生時代比較多是個人專案的獨立作業，專案規模較小型、缺乏有制度的組織規劃，所以希望能在實習期間更加瞭解或是涉身經歷這些大型專案的開發流程，增加大型專案前後端的合作經驗。技術層面則希望能先紮穩原生 JavaScript 的觀念再學習 Webpack、ES6 或其他現代框架，以理解背後目的和提升品質為前提去精進自我能力。</p></blockquote><p>以上是我在實習前對工作型態的期許，然而在面試時前輩也跟我大致做了說明：</p><ul><li>新技術如 Webpack / ES6 等等，公司在三年內大概都不會考慮投入專案<ul><li>考量瀏覽器相容性問題</li><li>團隊人力不足以兼顧專案的重構與維護</li></ul></li><li>撇開新技術不談，由於公司的專案已發展九年之久，可能會遇到以下情形<ul><li>開發初期不是非常注重 software engineering principles，導致專案結構有些鬆散</li><li>當然也有些 legacy code 和稀泥</li></ul></li><li>公司在這段實習期間可以提供<ul><li>前端部分今年初做了許多 refactoring，可以給予 follow up / study</li><li>能直接投入大型專案的開發流程，累積經驗與學習</li><li>由於從事社群網路服務，公司與用戶間的交流相當直接開放，團隊也對於使用者經驗也有扎實的心得</li></ul></li></ul><h2 id="正式上路"><a href="#正式上路" class="headerlink" title="正式上路"></a>正式上路</h2><p>我所負責的工作內容是與團隊中另一位後端實習工程師，一同開發 <strong>Bookmark feature</strong>，也就是讓使用者可以自由儲存他感興趣的 post 內容，提供更加便利的方式以再次瀏覽，同時也必須整合原有的專案結構去增加新 UI 、加入整個新功能。 </p><p>實習初期主要花了一些時間去瞭解網站的專案架構，有些頭緒後才開始涉身投入開發過程。</p><h4 id="接觸的新事物"><a href="#接觸的新事物" class="headerlink" title="接觸的新事物"></a>接觸的新事物</h4><ul><li>MVC 架構<ul><li>Mako<br>Python 模板</li><li>LESS<br>CSS 預處理器（寫過 SASS 所以上手很快）</li><li>Handlebars.js<br>JavaScript 模板引擎</li><li>RESTful API<br>與後端工程師溝通、分工合作</li></ul></li><li>Git<br>雖用過 github 此類遠端儲存庫，然而在這之前並沒有多人開發的版本控制經驗<br>有些情況下可以下一些特別的 git 指令，只能說真的沒用過不會知道啊XD</li><li>i18n<br>作為一個國際化的社群網站，多國語言翻譯是一定要的啦</li></ul><h2 id="思想衝擊"><a href="#思想衝擊" class="headerlink" title="思想衝擊"></a>思想衝擊</h2><p>作為一個新鮮人，在實際投入業界以後，我開始對於過去在學校的所見所聞有了更加深刻的體會，同時也接收了一些未曾想過的開發新觀點。</p><h4 id="從作業到產品"><a href="#從作業到產品" class="headerlink" title="從作業到產品"></a>從作業到產品</h4><p>在校作業往往有明確的要求與規範，然而實際開發新產品、新功能時，一切都從零開始。</p><p>成為開發者的同時，讓我比以前更加在意程式效能。雖然我不是後端、不負責資料庫的架構設計，但是掌握過去所學的核心科目（資料結構、演算法），確實對於寫好程式碼有極大幫助，至少會養成習慣去分析並且選擇最佳解決方法。</p><p>僅僅是功能寫好是遠遠不夠的，其中一個感受深刻的部分是<strong>資訊安全層面</strong>的考量，這次開發新功能我也對 CSRF、XSS 等攻擊手法做了不少功課，這些也都是在校時期較少接觸的部分。</p><h4 id="提高程式碼的架構可讀性"><a href="#提高程式碼的架構可讀性" class="headerlink" title="提高程式碼的架構可讀性"></a>提高程式碼的架構可讀性</h4><p>實習之中隨著元件越加越多，程式碼也被我越改越亂，當我意識到的同時已然變成了 <a href="https://en.wikipedia.org/wiki/Spaghetti_code">Spaghetti code</a>。</p><p>只好捧著程式碼去向前輩討教，也好好重新檢視了自己的 coding style——主要是疏於注意重複性程式碼，導致寫出維護性與可讀性不佳的程式碼。在撰寫起初也許不認為這段 code 包成 function 會有多大的效益，但是隨著程式越改越長，如果能好好管理、組織程式結構，積少成多下來會帶來可觀的影響。</p><h4 id="打造最佳的使用者體驗"><a href="#打造最佳的使用者體驗" class="headerlink" title="打造最佳的使用者體驗"></a>打造最佳的使用者體驗</h4><p>就如同前面所說的，僅僅是功能寫好是遠遠不夠的，尤其前端工程師必須扛起整個網頁與使用者互動的門面，也開始讓我更常思考——要怎麼樣設計界面和規劃每個元件的事件，才能讓使用者容易上手、便於使用。我想這個部分我還需要多加琢磨。</p><h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><blockquote><p>  “Tell me and I forget, Teach me and I remember, Involve me and I learn.” - Benjamin Franklin</p></blockquote><p>這段話可作為我這段日子以來的最佳寫照。兩個月的實習過得比想像中快，我也學到超乎原先預期的東西和觀念。</p><p>同時我也有感於一天只有二十四小時真的好不夠，開始工作的每一天，往往覺得自己越是學習越是不足，還有好多新事物在等著我去探索，也是和這個部落格的標題有所呼應吧。</p><p>最後很幸運地，原先團隊並沒有打算招收新的正職工程師，然而在這段期間經過公司的評估後，卻開給了我正職<strong>前端工程師</strong>的 offer。很高興獲得團隊的肯定，期許自己能在工作過程中學習更多，未來我也會好好全力以赴。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;今年四月，我投遞出人生的第一份履歷。&lt;/p&gt;
&lt;p&gt;我使用該公司的社群網路服務已有近七年之久，於是當他們釋出前端工程師的實習職位，考慮不過半天、回過神來我已將履歷投至對方信箱——也很幸運地，在經過篩選與面試後，我獲得了暑期實習的合作機會。&lt;/p&gt;
&lt;p&gt;經過一段時間沈澱之後，我想我是該好好寫篇文章，分享我在短短兩個月的實習過程之中的所見所學。&lt;/p&gt;
    
    </summary>
    
    
      <category term="生活紀錄" scheme="https://blog.weitw.net/categories/%E7%94%9F%E6%B4%BB%E7%B4%80%E9%8C%84/"/>
    
    
      <category term="Frontend" scheme="https://blog.weitw.net/tags/Frontend/"/>
    
  </entry>
  
  <entry>
    <title>使用 Sublime SFTP 同步檔案</title>
    <link href="https://blog.weitw.net/posts/83ff426e/"/>
    <id>https://blog.weitw.net/posts/83ff426e/</id>
    <published>2017-08-23T12:26:07.000Z</published>
    <updated>2019-12-27T17:27:41.866Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在開始介紹 SFTP 以前，我們要先聊聊 <strong>SSH (Secure Shell)</strong> 協定。沒聽過 SSH 嗎？</p><p>那你或許有聽過 <strong>Telnet</strong>，沒錯！就是廣大鄉民們平常用來上 PTT 的連線協定。<br>Telnet 易用，速度又快，只要執行 Telnet 程式來連線到遠端伺服器，使用者輸入帳密後便可以遠端控制主機。</p><p>但是由於 Telnet 傳輸的資料並未加密，所以容易遭到竊取，後來 SSH 橫空出世，SSH 預設是以金鑰為基礎來驗證及加密傳輸，也可以省去輸入帳號密碼的步驟，大家也就多改用較為安全的 SSH。</p><h2 id="SSH（Secure-Shell）"><a href="#SSH（Secure-Shell）" class="headerlink" title="SSH（Secure Shell）"></a>SSH（Secure Shell）</h2><p>接下來我們進一步介紹 SSH 協定的運作原理：</p><ol><li>靠加密編碼的演算法，產生一組很長又混亂的字串及檔案</li><li>這組資料分別為<strong>私鑰 (private key)</strong> 與<strong>公鑰 (public key)</strong></li><li>接著<strong>將公鑰傳至想要可以免帳號密碼登入的主機上</strong></li><li>登入主機進行驗證後，主機就會認為你是經過驗證的使用者，就可以登入囉。</li></ol><a id="more"></a><h2 id="在-OSX-與-Linux-環境下產生-SSH-key"><a href="#在-OSX-與-Linux-環境下產生-SSH-key" class="headerlink" title="在 OSX 與 Linux 環境下產生 SSH key"></a>在 OSX 與 Linux 環境下產生 SSH key</h2><p>由於 OS X 跟 Linux 都是 Unix-Like 系統，所以產生的方式都一樣。<br>步驟如下：</p><ol><li>使用內建的終端機 </li><li><code>ssh-keygen</code> 建立 ssh key</li><li><code>ls -al</code> 會看到生成了兩個檔案：<code>id_rsa.pub</code> <code>id_rsa</code><br>也就是你所持有的公鑰與私鑰</li><li>把 <code>id_rsa.pub</code> 的內容加入 server 端的 <code>~/.ssh/authorized_keys</code></li><li>建立連線 <code>ssh USER@SSH_SERVER</code></li></ol><h2 id="在-Windows-環境下產生-SSH-key"><a href="#在-Windows-環境下產生-SSH-key" class="headerlink" title="在 Windows 環境下產生 SSH key"></a>在 Windows 環境下產生 SSH key</h2><p>在 Windows 中有兩種類型的程式可以支援 SSH：</p><ul><li><strong>OpenSSH</strong> - 安裝完 git 會自動安裝</li><li><strong>PuTTY</strong></li></ul><p>使用 <strong>OpenSSH</strong> 的步驟如下：</p><ol><li>使用 PowerShell  </li><li>安裝 git 會順便安裝 OpenSSH</li><li>先建立 .ssh 的資料夾<br>通常安裝 git 的時候在產生 github_rsa 的時候就已經建好了</li><li><code>ssh-keygen</code> 建立 ssh key</li><li><code>ls</code> 會看到生成了兩個檔案：<code>id_rsa.pub</code> <code>id_rsa</code></li><li>把 <code>id_rsa.pub</code> 的內容加入 server 端的 <code>~/.ssh/authorized_keys</code></li><li>建立連線 <code>ssh USER@SSH_SERVER</code></li></ol><p>雖然可以順利的手動連線，但是很遺憾的，<strong>OpenSSH</strong> 的公鑰/私鑰的格式和 Linux 環境之下是不同的，由於我們之後還想要使用 <strong>SFTP</strong>，為了避免在後續操作會導致 <code>Sublime SFTP Connection timeout</code>，那就必須利用 <strong>puttygen.exe</strong> 對公鑰/私鑰進行格式轉換。</p><p>這樣做實在太麻煩了，不如我們就直接使用 <strong>puttygen.exe</strong> 來生成金鑰吧：</p><ol><li>使用 PowerShell  </li><li>下載 <strong>puttygen.exe</strong>，打開之後點選 Generate<br>滑鼠在 key 區空白位置晃動，可加快生成隨機數</li><li>在 key comment 填寫備註</li><li>在 key passphras 填寫 key 的密碼，如同前面步驟，也可以選擇不設置</li><li>把上方框框中的內容，也就是公鑰複製到 server 端的 <code>/.ssh/authorized_keys</code> 之中</li><li>點擊 puttygen.exe 中的 Save private key，保存私鑰 <strong>id_rsa.ppk</strong></li><li>建立連線 <code>ssh USER@SSH_SERVER</code></li></ol><h2 id="使用-Sublime-SFTP-同步檔案"><a href="#使用-Sublime-SFTP-同步檔案" class="headerlink" title="使用 Sublime SFTP 同步檔案"></a>使用 Sublime SFTP 同步檔案</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">註：本文撰寫於 2017&#x2F;08，我後來跳槽使用 VSCode。</span><br><span class="line">官方直接支援 SSH 連線到伺服器進行開發，我認為方便多了。</span><br></pre></td></tr></table></figure><p>來到本文的正題，也就是如何在 <a href="https://www.sublimetext.com/3">Sublime Text3</a> 上借助 <a href="https://wbond.net/sublime_packages/sftp">SFTP</a> 這個套件來幫助我們更加快速與便利地去建立 SSH 連線和管理檔案：</p><ul><li><strong>安裝 SFTP</strong><br>如同其他套件，利用 <code>package control install package</code> 輸入 <code>sftp</code> 後就會自動下載</li><li><strong>配置文件</strong><br>在第一次執行之前，我們必須設定配置文件 <code>sftp-sonfig.json</code><br>簡單介紹幾個選項</li><li>連線設定<ul><li><code>type</code> 有 sftp, ftp, ftps 等連線可選，在這裡我們選擇 <code>sftp</code></li><li><code>host</code> SSH_SERVER</li><li><code>user</code> USER</li><li><code>password</code> 預設沒有使用的話，註解就好</li><li><code>port</code> 沒有指定的話，註解就好</li><li><code>ssh_key_file</code> 在 windows 環境中，設定成剛才儲存的 <strong>id_rsa.ppk</strong> 的路徑，<br>例如 <code>&quot;C:\/Users\/username\/.ssh\/id_rsa.ppk&quot;</code></li></ul></li><li>同步設定<ul><li><code>save_before_upload</code> 上傳前，local 自動存檔</li><li><code>sync_down_on_open</code> local 開啟檔案時，自動從遠端同步（保留 local 原 code）</li><li><code>sync_skip_deletes</code> 同步時，跳過刪除的檔案</li><li><code>sync_same_age</code> 時間戳相同的檔案一併同步</li><li><code>confirm_downloads</code> 下載時不要詢問</li><li><code>confirm_sync</code> 同步時不要詢問</li><li><code>confirm_overwrite_newer</code> 覆寫時不要詢問</li></ul></li><li>同步檔案<ul><li><code>remote_path</code> 遠端同步的資料夾</li><li><code>ignore_regexes</code> 同步資料夾下忽略的檔案</li></ul></li><li><strong>進行連線</strong><br>儲存配置文件後，即可在目錄按下滑鼠右鍵直接操作<br><img src="http://i.imgur.com/6iF3MY7.png" alt=""></li></ul><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul><li><a href="http://blog.itist.tw/2015/03/login-ssh-server-without-username-and-password.html">別讓 MIS 不開心，免密碼直接登入遠端的 SSH Server</a></li><li><a href="https://kknews.cc/other/y8k2a2k.html">SublimeText3中使用SFTP編輯遠程伺服器文件</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在開始介紹 SFTP 以前，我們要先聊聊 &lt;strong&gt;SSH (Secure Shell)&lt;/strong&gt; 協定。沒聽過 SSH 嗎？&lt;/p&gt;
&lt;p&gt;那你或許有聽過 &lt;strong&gt;Telnet&lt;/strong&gt;，沒錯！就是廣大鄉民們平常用來上 PTT 的連線協定。&lt;br&gt;Telnet 易用，速度又快，只要執行 Telnet 程式來連線到遠端伺服器，使用者輸入帳密後便可以遠端控制主機。&lt;/p&gt;
&lt;p&gt;但是由於 Telnet 傳輸的資料並未加密，所以容易遭到竊取，後來 SSH 橫空出世，SSH 預設是以金鑰為基礎來驗證及加密傳輸，也可以省去輸入帳號密碼的步驟，大家也就多改用較為安全的 SSH。&lt;/p&gt;
&lt;h2 id=&quot;SSH（Secure-Shell）&quot;&gt;&lt;a href=&quot;#SSH（Secure-Shell）&quot; class=&quot;headerlink&quot; title=&quot;SSH（Secure Shell）&quot;&gt;&lt;/a&gt;SSH（Secure Shell）&lt;/h2&gt;&lt;p&gt;接下來我們進一步介紹 SSH 協定的運作原理：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;靠加密編碼的演算法，產生一組很長又混亂的字串及檔案&lt;/li&gt;
&lt;li&gt;這組資料分別為&lt;strong&gt;私鑰 (private key)&lt;/strong&gt; 與&lt;strong&gt;公鑰 (public key)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;接著&lt;strong&gt;將公鑰傳至想要可以免帳號密碼登入的主機上&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;登入主機進行驗證後，主機就會認為你是經過驗證的使用者，就可以登入囉。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="技術心得" scheme="https://blog.weitw.net/categories/%E6%8A%80%E8%A1%93%E5%BF%83%E5%BE%97/"/>
    
    
      <category term="Sublime" scheme="https://blog.weitw.net/tags/Sublime/"/>
    
      <category term="SFTP" scheme="https://blog.weitw.net/tags/SFTP/"/>
    
  </entry>
  
  <entry>
    <title>淺談 Polling, Comet, Websocket</title>
    <link href="https://blog.weitw.net/posts/2b10bcfa/"/>
    <id>https://blog.weitw.net/posts/2b10bcfa/</id>
    <published>2017-07-31T05:02:28.000Z</published>
    <updated>2019-12-27T17:27:41.866Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>現在需要做即時回應與更新的網站已是愈來愈多，大至 Facebook、Twitter，小至即時聊天室的實作等等，在以前使用者只能靠著重新載入網頁才能獲得最新的資訊，但是這樣不但很浪費時間，也會佔用很多不必要的網路資源，並不是一個好的方式。</p><p>現在要實作這樣的功能，當然不能不知道一些<strong>網路推播技術 Internet Push technology</strong>——對這個名詞很陌生嗎？讓我們來看看<a href="https://zh.wikipedia.org/wiki/%E6%8E%A8%E9%80%81%E6%8A%80%E6%9C%AF">維基百科</a>的說明：</p><blockquote><p>  <strong>推播技術</strong>，是一種基於 Internet 通訊方式的伺服器推播，其中要求通訊的請求是由發布者或中央伺服器發起。與 pull/get 形成對比，資訊傳輸的相應一般由接收者或用戶端發起。<br>  推動服務通常是基於提前的資訊預設定上。也就是所謂的 publish/subscribe 模型，客戶通過訂閱由伺服器提供各種資訊的頻道，不論何時都可以在其中一個頻道得到新的內容，同樣伺服器通過推播把資訊傳遞給相應的用戶端。</p></blockquote><a id="more"></a><h2 id="Polling-輪詢"><a href="#Polling-輪詢" class="headerlink" title="Polling 輪詢"></a>Polling 輪詢</h2><p>先來談談傳統的 <strong>Polling 輪詢技術</strong>，基本上原理很簡單，就是每隔一段固定時間就自動送出 Request 給伺服器，去跟伺服器要資料就對了！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">poll</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      $.ajax(&#123; <span class="attr">url</span>: <span class="string">"server"</span>, <span class="attr">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// Do something to update your view</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Setup the next poll recursively</span></span><br><span class="line">        poll();</span><br><span class="line">      &#125;, <span class="attr">dataType</span>: <span class="string">"json"</span>&#125;);</span><br><span class="line">  &#125;, <span class="number">30000</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>它有以下幾個特點：</p><ul><li>容易實作</li><li>沒有跨瀏覽器的問題</li><li>不需要特殊伺服器做配合</li></ul><p>但也有致命的缺點：</p><ul><li>沒效率</li><li>浪費頻寬</li></ul><p>這個做法是最老舊的方式，如果你已經事先知道伺服器上資料更新的頻率或時間，那麼也許用這樣的方式去做資料的同步更新。<br>但現在許多的網頁應用程式上並不是這樣，你通常不會知道伺服器上的資料何時會更新，在伺服器沒有新資料時，瀏覽器如果也送出 Request，就會造成浪費網路資源的狀況。而 Comet 的出現解決了 Polling 這樣的弊端。</p><h2 id="Comet"><a href="#Comet" class="headerlink" title="Comet"></a>Comet</h2><p><strong>Comet</strong> 在英文中也就是彗星的意思，顧名思義發出的 Request 會像彗星的尾巴般，將 Request 拉長，讓伺服器可以想傳資料就傳，不需要等客戶端先送請求伺服器再回傳，<strong>讓伺服器實時地將更新的資訊傳送到用戶端</strong>。</p><p>Comet 原先的精神是發出 Request 後不馬上結束，但這種做法卻引申出另一個問題那就是他會把傳統的 Web 伺服器（例如 Apache）的連線給佔住。所以 Comet 的技術得配合 <strong>Non-Blocking IO</strong> 的 Web 伺服器才能非同步處理。</p><p>後來發展出改良式的 Comet，伺服器會發一個長時間等待的 Request、當伺服器有資料 Response 時立刻斷掉、接著再發一個新的 Request。</p><p>這種改良式的 Comet 主要有兩種實作方式：</p><ul><li><p><strong>Long Polling 長時間輪詢</strong><br>Long Polling 的原理是瀏覽器發出一個 Request，而伺服器讓這個 Request 持續開啟一段時間，若在這時間間隔內伺服器有資料就會回傳給客戶端，如果沒有則超時後伺服器會關上 Request。瀏覽器收到回應後，才會再重新發出一個 Request。</p><p><img src="https://i.imgur.com/bijGnVj.png" alt=""></p><p>與 Polling 的不同之處就在於它是比較有效率的、可以等到 timeout 或拿到資料時再重新發、因此減少不必要的流量浪費。但是，這種情況下當傳送的訊息相當龐大時，可能會造成傳送不完全，使得控制失靈。</p></li><li><p><strong>Streaming 串流</strong><br>Streaming 的原理則是讓伺服器與客戶端建立起一條持續的連線，為了使連線不中斷，伺服器每隔一段時間會發送 Response 給客戶端，確保連線不中斷，在 Streaming 中使用隱藏的 <strong>iframe tag</strong>，伺服器將資料傳入 iframe，交給其中的 javascript 去執行頁面的更新。</p><p><img src="https://i.imgur.com/GzYQEuM.png" alt=""></p><p>使用 Streaming 有一些缺點，由於他是建立在 HTTP 協定上的一種傳輸機制，訊息會被包裝起來，所以可能會因為 <strong>代理伺服器（proxy）</strong> 或 <strong>防火牆（firewall）</strong> 將其中的資料存放在 <strong>緩衝區 （Buffer）</strong> 中，造成傳送上的延遲，因此許多使用串流的 Comet 實作會在偵測到有代理伺服器的狀況時，改用長時間輪詢的方式處理。</p></li></ul><p><img src="https://i.imgur.com/t6HiEi8.png" alt=""></p><p>瞭解 Comet 的原理後，我們其實可以發現 Comet 的最大瓶頸在於控制連線生命週期上需要反覆發出請求，而導致效能會較差，然而 <strong>WebSocket</strong> 的出現卻解決了這個問題，讓效能不會卡在連線生命週期，增強了資料傳輸的效率。</p><h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><p><strong>WebSocket</strong> 是定義在 HTML5 標準中的一個新的網頁傳輸方式，可在一條連線上提供<strong>全雙工、雙向的資料傳輸</strong>。在這樣的標準下你可以很容易實作一個兼具可擴充性與即時性的網頁應用程式。</p><p>同時因為 WebSocket 提供瀏覽器一個 <strong>原生（native）</strong> 的 socket，所以直接解決了 Comet 架構很容易出錯的問題，而在整個架構的複雜度上也會比傳統的做法簡單很多。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017051502.png" alt=""></p><p>簡單來說就是利用了新的協定建立了雙向的通道：當通道建立起來之後，Browser 可以隨時丟訊息給 Server、Server 可以隨時丟訊息給瀏覽器。唯一的小缺點就是可能有一些瀏覽器相容性的問題必須要解決，IE10 以前的版本並不支援。</p><p>在使用前，需要建立一個 WebSocket 物件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">'ws://server'</span>);</span><br><span class="line">  ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">    alert(message.data);</span><br><span class="line">    ws.close()</span><br><span class="line">  &#125;;</span><br><span class="line">ws.send(<span class="string">'Hello WebSocket.'</span>);</span><br></pre></td></tr></table></figure><p>WebSocket 可以選擇 <strong>ws</strong> 或是 <strong>wss</strong> 通訊協定。</p><ul><li>ws 就相當於一般的 http</li><li>wss 則相當於 https，需要伺服器可以支援</li></ul><p>操作上十分單純，以 <code>send()</code> 送出訊息，而以 <code>onmessage</code> 事件接收訊息。<br>呼叫 <code>close()</code> 即可結束連線。這中間無法改變通訊的 url。</p><p>比起前端的使用操作，在後端、伺服器上實作 WebSocket Protocol 倒是複雜多了。這部分就不多贅述。</p><p>總而言之，透過 WebSocket 建立永久連線，這種開放式連線可以讓客戶端和伺服器端之間隨時雙向交換資料，因此可降低延遲時間，改善資源使用效率，必定會是未來的潮流和趨勢。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;現在需要做即時回應與更新的網站已是愈來愈多，大至 Facebook、Twitter，小至即時聊天室的實作等等，在以前使用者只能靠著重新載入網頁才能獲得最新的資訊，但是這樣不但很浪費時間，也會佔用很多不必要的網路資源，並不是一個好的方式。&lt;/p&gt;
&lt;p&gt;現在要實作這樣的功能，當然不能不知道一些&lt;strong&gt;網路推播技術 Internet Push technology&lt;/strong&gt;——對這個名詞很陌生嗎？讓我們來看看&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%8E%A8%E9%80%81%E6%8A%80%E6%9C%AF&quot;&gt;維基百科&lt;/a&gt;的說明：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;  &lt;strong&gt;推播技術&lt;/strong&gt;，是一種基於 Internet 通訊方式的伺服器推播，其中要求通訊的請求是由發布者或中央伺服器發起。與 pull/get 形成對比，資訊傳輸的相應一般由接收者或用戶端發起。&lt;br&gt;  推動服務通常是基於提前的資訊預設定上。也就是所謂的 publish/subscribe 模型，客戶通過訂閱由伺服器提供各種資訊的頻道，不論何時都可以在其中一個頻道得到新的內容，同樣伺服器通過推播把資訊傳遞給相應的用戶端。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="技術心得" scheme="https://blog.weitw.net/categories/%E6%8A%80%E8%A1%93%E5%BF%83%E5%BE%97/"/>
    
    
      <category term="HTML5" scheme="https://blog.weitw.net/tags/HTML5/"/>
    
      <category term="AJAX" scheme="https://blog.weitw.net/tags/AJAX/"/>
    
      <category term="Comet" scheme="https://blog.weitw.net/tags/Comet/"/>
    
      <category term="Websocket" scheme="https://blog.weitw.net/tags/Websocket/"/>
    
  </entry>
  
  <entry>
    <title>HTML5 的資料屬性 (data-* attribute)</title>
    <link href="https://blog.weitw.net/posts/2bb3134/"/>
    <id>https://blog.weitw.net/posts/2bb3134/</id>
    <published>2017-07-08T14:55:36.000Z</published>
    <updated>2019-12-27T17:27:41.862Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>常常在 html 之中看到形如 <code>data-* attribute</code> 的資料屬性，以下面這段程式碼為例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"controls"</span>  <span class="attr">data-uid</span>=<span class="string">"$&#123;session_user.id&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"like_post"</span> <span class="attr">class</span>=<span class="string">"s_$&#123;post.favorite&#125;"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">void</span> <span class="attr">class</span>=<span class="string">"do pif-like"</span> <span class="attr">data-function</span>=<span class="string">"like"</span>&gt;</span>$&#123;_("like")&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">void</span> <span class="attr">class</span>=<span class="string">"undo pif-like"</span> <span class="attr">data-function</span>=<span class="string">"unlike"</span>&gt;</span>$&#123;_("unlike")&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>這段程式碼之中，有的元素被賦予了 <code>data-uid</code> 的屬性，有的則是被賦予了 <code>data-function</code> 的屬性。</p><p>然而如果你直接 google  <code>data-uid</code> 或是 <code>data-function</code> 卻也查不太到這個屬性，這到底是什麼？又有什麼意義或用途呢？</p><a id="more"></a><h2 id="HTML5-中的-data-attribute"><a href="#HTML5-中的-data-attribute" class="headerlink" title="HTML5 中的 data-* attribute"></a>HTML5 中的 data-* attribute</h2><p><strong>HTML5</strong> 中的 <strong><code>data-* attribute</code></strong> 事實上是一種自定義的屬性，讓我們可以上所有 HTML 元素之中嵌入自定義的屬性，而之所以會有這個自定義屬性的出現，不只是為了方便 programer 能理解，同時最後也能再經由 JavaScript / jQuery 去存取。</p><p>data-* attribute 屬性包含兩個部分：</p><ul><li>屬性名稱不能包含任何大寫字母，同時在前綴字 <strong>data-</strong> 之後則必須至少要有一個字</li><li>屬性值則可以是任何的字串</li></ul><p>由於這是一個自定義名稱，所以當我們想去 google  <code>data-uid</code> 或是 <code>data-function</code> 也就會找不到答案。</p><h2 id="利用-JavaScript-來取值"><a href="#利用-JavaScript-來取值" class="headerlink" title="利用 JavaScript 來取值"></a>利用 JavaScript 來取值</h2><p>當我們想取得 data-* attribute 的屬性值時，我們可以利用 JavaScript 的 <code>dataset</code> 物件來存取。</p><p>以前面的程式碼為例，假如我們想取得 <code>#like_post</code> 之中的 <code>data-function</code> ，可以寫成這樣：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ele = <span class="built_in">document</span>.getElementById(<span class="string">'like_post'</span>);  </span><br><span class="line"><span class="keyword">var</span> func = ele.dataset<span class="function">.<span class="keyword">function</span>;</span></span><br></pre></td></tr></table></figure><p>如果考慮瀏覽器相容性，也可以利用 <code>getAttribute</code> 去操作，然而速度與可讀性上還是 <code>dataset</code> 較佳。</p><h2 id="利用-jQuery-來取值"><a href="#利用-jQuery-來取值" class="headerlink" title="利用 jQuery 來取值"></a>利用 jQuery 來取值</h2><p>利用 jQuery 更是方便，使用內建的 <code>.data()</code> 就能夠存取我們想要的屬性值了，能寫成這樣：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ele = <span class="built_in">document</span>.getElementById(<span class="string">'like_post'</span>);  </span><br><span class="line"><span class="keyword">var</span> func = ele.data(<span class="string">'function'</span>);</span><br></pre></td></tr></table></figure><p>是不是相當的方便呢？只要能善用 <strong><code>data-* attribute</code></strong> ，就能夠幫助我們更有效率地去存取這些值。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;常常在 html 之中看到形如 &lt;code&gt;data-* attribute&lt;/code&gt; 的資料屬性，以下面這段程式碼為例：&lt;/p&gt;
&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;controls&quot;&lt;/span&gt;  &lt;span class=&quot;attr&quot;&gt;data-uid&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;$&amp;#123;session_user.id&amp;#125;&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;span&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;like_post&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;s_$&amp;#123;post.favorite&amp;#125;&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;do pif-like&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;data-function&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;like&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;$&amp;#123;_(&quot;like&quot;)&amp;#125;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;a&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;undo pif-like&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;data-function&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;unlike&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;$&amp;#123;_(&quot;unlike&quot;)&amp;#125;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;a&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;span&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;這段程式碼之中，有的元素被賦予了 &lt;code&gt;data-uid&lt;/code&gt; 的屬性，有的則是被賦予了 &lt;code&gt;data-function&lt;/code&gt; 的屬性。&lt;/p&gt;
&lt;p&gt;然而如果你直接 google  &lt;code&gt;data-uid&lt;/code&gt; 或是 &lt;code&gt;data-function&lt;/code&gt; 卻也查不太到這個屬性，這到底是什麼？又有什麼意義或用途呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="技術心得" scheme="https://blog.weitw.net/categories/%E6%8A%80%E8%A1%93%E5%BF%83%E5%BE%97/"/>
    
    
      <category term="JavaScript" scheme="https://blog.weitw.net/tags/JavaScript/"/>
    
      <category term="jQuery" scheme="https://blog.weitw.net/tags/jQuery/"/>
    
      <category term="HTML5" scheme="https://blog.weitw.net/tags/HTML5/"/>
    
  </entry>
  
  <entry>
    <title>Gulp 建立自己的自動化程序</title>
    <link href="https://blog.weitw.net/posts/c606cc8a/"/>
    <id>https://blog.weitw.net/posts/c606cc8a/</id>
    <published>2017-04-14T17:44:20.000Z</published>
    <updated>2019-12-27T17:27:41.862Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在進行網頁開發的時候，過程中可能有許多問題需要處理，以我的開發習慣來舉例：</p><ul><li>編譯 SASS, Pug</li><li>壓縮 <code>.css</code>, <code>.js</code> 或圖檔</li><li>修改完成之後要不斷 F5 重整頁面</li><li>諸如此類…</li></ul><p>雖然很多工具都可以完成各別的功能，但這樣在開發的過程中反而顯得相當沒效率，這時候我們就可以利用 <a href="http://gulpjs.com/">Gulp</a> 來協助我們建立自己的自動化程序。</p><h2 id="安裝全域-Gulp"><a href="#安裝全域-Gulp" class="headerlink" title="安裝全域 Gulp"></a>安裝全域 Gulp</h2><p>Gulp 是 Node.js 的套件，所以必須先安裝 Node.js 才可以安裝。</p><p>檢查 npm 版本，3.0.2 以上才可順利安裝 Gulp</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm --version</span><br></pre></td></tr></table></figure><p>安裝全域 Gulp</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install gulp --global</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="安裝-Gulp-套件"><a href="#安裝-Gulp-套件" class="headerlink" title="安裝 Gulp 套件"></a>安裝 Gulp 套件</h2><p>首先要進行專案初始化，在專案資料夾底下輸入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure><p>安裝所要使用的套件，會產生一個 <code>node_modules</code> 資料來存放所有套件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install gulp gulp-sass gulp-pug gulp-uglify gulp-imagemin gulp-connect gulp-livereload -save-dev</span><br></pre></td></tr></table></figure><p>我個人常用的套件有下面這些：</p><ul><li>gulp-sass：CSS preprocessor，內建 CSS 檔案壓縮</li><li>gulp-pug：HTML 的模板，原名是 Jade</li><li>gulp-uglify：JavaScript 混淆與檔案壓縮</li><li>gulp-imagemin：自動壓縮圖檔，支援 PNG, JPEG, GIF 和 SVG</li><li>gulp-connect：在本地建立起網頁伺服器</li><li>gulp-livereload：以伺服器方式打開網頁，搭配 <a href="https://chrome.google.com/webstore/detail/livereload/jnihajbhpnppcggbcgedagnkighmdlei">chrome 插件</a>自動刷新頁面</li></ul><h2 id="資料夾結構"><a href="#資料夾結構" class="headerlink" title="資料夾結構"></a>資料夾結構</h2><p>在使用 Gulp 時，資料夾結構會影響到 Gulp 配置檔（<code>gulpfile.js</code>）的部分。</p><p>以下是我的資料夾結構配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">|- src/    <span class="comment">#開發時的專案檔案資料夾</span></span><br><span class="line">    |- images/</span><br><span class="line">    |- index.js</span><br><span class="line">    |- style.sass</span><br><span class="line">    |- index.pug</span><br><span class="line">|- dist/    <span class="comment">#最終專案匯出的資料夾</span></span><br><span class="line">    |- images/</span><br><span class="line">    |- index.js</span><br><span class="line">    |- style.css</span><br><span class="line">    |- index.html</span><br><span class="line">|- gulpfile.js</span><br><span class="line">|- package.json</span><br><span class="line">|- node_modules/</span><br></pre></td></tr></table></figure><h2 id="建立-gulpfile-js"><a href="#建立-gulpfile-js" class="headerlink" title="建立 gulpfile.js"></a>建立 gulpfile.js</h2><p>接下來在專案目錄下建立 <code>gulpfile.js</code>，這裡就不贅述細節，直接附上程式碼。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import plugin</span></span><br><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>),</span><br><span class="line">    sass = <span class="built_in">require</span>(<span class="string">'gulp-sass'</span>)</span><br><span class="line">    pug = <span class="built_in">require</span>(<span class="string">'gulp-pug'</span>)</span><br><span class="line">    uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>)</span><br><span class="line">    imagemin = <span class="built_in">require</span>(<span class="string">'gulp-imagemin'</span>)</span><br><span class="line">    connect = <span class="built_in">require</span>(<span class="string">'gulp-connect'</span>)</span><br><span class="line">    livereload = <span class="built_in">require</span>(<span class="string">'gulp-livereload'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// file paths</span></span><br><span class="line"><span class="keyword">const</span> stylePath = &#123;<span class="attr">src</span>: <span class="string">'src/*.sass'</span>, <span class="attr">dest</span>: <span class="string">'dist'</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> htmlPath = &#123;<span class="attr">src</span>: <span class="string">'src/*.pug'</span>, <span class="attr">dest</span>: <span class="string">'dist'</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> scriptPath = &#123;<span class="attr">src</span>: <span class="string">'src/*.js'</span>, <span class="attr">dest</span>: <span class="string">'dist'</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> imagePath = &#123;<span class="attr">src</span>: <span class="string">'src/images/**'</span>, <span class="attr">dest</span>: <span class="string">'dist/images'</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// default</span></span><br><span class="line">gulp.task(<span class="string">'default'</span>, [<span class="string">'sass'</span>, <span class="string">'pug'</span>, <span class="string">'js'</span>, <span class="string">'images'</span>, <span class="string">'server'</span>, <span class="string">'watch'</span>]);</span><br><span class="line"><span class="comment">// gulp-connect</span></span><br><span class="line">gulp.task(<span class="string">'server'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  connect.server(&#123;</span><br><span class="line">    root: <span class="string">''</span>,</span><br><span class="line">    livereload: <span class="literal">true</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// gulp-sass</span></span><br><span class="line">gulp.task(<span class="string">'sass'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> gulp.src(stylePath.src)</span><br><span class="line">          .pipe(sass()) <span class="comment">// compile sass into CSS</span></span><br><span class="line">          .pipe(gulp.dest(stylePath.dest))</span><br><span class="line">          .pipe(connect.reload())</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// gulp-pug</span></span><br><span class="line">gulp.task(<span class="string">'pug'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gulp.src(htmlPath.src)</span><br><span class="line">    .pipe(pug(&#123; <span class="comment">// compile pug into HTML</span></span><br><span class="line">      pretty: <span class="literal">true</span></span><br><span class="line">    &#125;))</span><br><span class="line">    .pipe(gulp.dest(htmlPath.dest))</span><br><span class="line">    .pipe(connect.reload())</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// gulp-uglify</span></span><br><span class="line">gulp.task(<span class="string">'js'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gulp.src(scriptPath.src)</span><br><span class="line">    .pipe(uglify())  <span class="comment">// minify JavaScript</span></span><br><span class="line">    .pipe(gulp.dest(scriptPath.dest))</span><br><span class="line">    .pipe(connect.reload())</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// gulp-imagemin  </span></span><br><span class="line">gulp.task(<span class="string">'images'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gulp.src(imagePath.src)</span><br><span class="line">    .pipe(imagemin())  <span class="comment">// minify images</span></span><br><span class="line">    .pipe(gulp.dest(imagePath.dest)) </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// watch</span></span><br><span class="line">gulp.task(<span class="string">'watch'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  gulp.watch(htmlPath.src, [<span class="string">'pug'</span>]);</span><br><span class="line">  gulp.watch(stylePath.src, [<span class="string">'sass'</span>]);</span><br><span class="line">  gulp.watch(scriptPath.src, [<span class="string">'js'</span>]);</span><br><span class="line">  gulp.watch(imagePath.src, [<span class="string">'images'</span>]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="執行-gulp"><a href="#執行-gulp" class="headerlink" title="執行 gulp"></a>執行 gulp</h2><p>輸入 <code>gulp</code> 就可以開始執行我們的自動化流程了！</p><p>每當有新專案時，只要複製前個專案的 <code>package.json</code> 和 <code>gulpfile.js</code> 再執行 <code>npm install</code> 就可以了。</p><p>我也把模板放上了 <a href="https://github.com/wei840220/GulpTemplate">Github</a>，日後也可以直接 fork 下來。</p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul><li><a href="https://www.gitbook.com/book/kejyuntw/gulp-learning-notes/details">gulp 學習筆記</a></li><li><a href="https://qq7886.gitbooks.io/gulp-beginner/content/">Gulp 基礎入門 - 2017</a></li><li><a href="http://www.oxxostudio.tw/articles/201503/gulp-4-scss-sass.html">Gulp 學習 - 建立 SCSS/SASS 編輯環境</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在進行網頁開發的時候，過程中可能有許多問題需要處理，以我的開發習慣來舉例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;編譯 SASS, Pug&lt;/li&gt;
&lt;li&gt;壓縮 &lt;code&gt;.css&lt;/code&gt;, &lt;code&gt;.js&lt;/code&gt; 或圖檔&lt;/li&gt;
&lt;li&gt;修改完成之後要不斷 F5 重整頁面&lt;/li&gt;
&lt;li&gt;諸如此類…&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;雖然很多工具都可以完成各別的功能，但這樣在開發的過程中反而顯得相當沒效率，這時候我們就可以利用 &lt;a href=&quot;http://gulpjs.com/&quot;&gt;Gulp&lt;/a&gt; 來協助我們建立自己的自動化程序。&lt;/p&gt;
&lt;h2 id=&quot;安裝全域-Gulp&quot;&gt;&lt;a href=&quot;#安裝全域-Gulp&quot; class=&quot;headerlink&quot; title=&quot;安裝全域 Gulp&quot;&gt;&lt;/a&gt;安裝全域 Gulp&lt;/h2&gt;&lt;p&gt;Gulp 是 Node.js 的套件，所以必須先安裝 Node.js 才可以安裝。&lt;/p&gt;
&lt;p&gt;檢查 npm 版本，3.0.2 以上才可順利安裝 Gulp&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm --version&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;安裝全域 Gulp&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm install gulp --global&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="技術心得" scheme="https://blog.weitw.net/categories/%E6%8A%80%E8%A1%93%E5%BF%83%E5%BE%97/"/>
    
    
      <category term="Gulp" scheme="https://blog.weitw.net/tags/Gulp/"/>
    
  </entry>
  
  <entry>
    <title>JSON &amp; AJAX 基本觀念與實作</title>
    <link href="https://blog.weitw.net/posts/6468559b/"/>
    <id>https://blog.weitw.net/posts/6468559b/</id>
    <published>2017-03-31T15:30:07.000Z</published>
    <updated>2019-12-27T17:27:41.866Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前在學校課程中實作資料庫內容的呈現時，是利用 PHP + MySQL 做資料的傳遞，然而在前後端分離的工作模式之中，只要前端從後端 API 那裡接到產出的資料，就可以直接執行頁面上的資料呈現與處理。</p><p>本文所要實作的內容如下：</p><ul><li>建構 <strong>JSON data file</strong> 存放預設資料</li><li>透過 <strong>jQuery 語法 ( Ajax )</strong> 讀取資料</li></ul><p>也就是說著重在前端接取資料並呈現的部分，不包含後端產生 JSON data file 的工作。</p><h2 id="什麼是-JSON"><a href="#什麼是-JSON" class="headerlink" title="什麼是 JSON"></a>什麼是 JSON</h2><p><img src="https://i.imgur.com/N4d8OPG.png" alt=""><br><strong>JSON（JavaScript Object Notation）</strong> 是一種輕量級的資料交換語言，後端透過資料庫整理成線上 JSON 格式 ，提供給前端使用，我們可以再經由 jQuery 去存取。</p><p>JSON 支援的資料型態有 string, number, array, object 等等，主要的宣告與 Javascript 無異，只是有些細節要注意：</p><ul><li>名稱為字串，必須用成對雙引號 “” 包括</li><li>值可以是雙引號包括的字串、數字、true、false、null、物件或者是陣列。</li><li>不支援 JavaScript 的 Date、Error、規則表示式或函式表示。</li></ul><a id="more"></a><h2 id="建立-JSON-data-file"><a href="#建立-JSON-data-file" class="headerlink" title="建立 JSON data file"></a>建立 JSON data file</h2><p>首先，我想建立一個存有餐廳名稱的物件陣列，可以每次自動讀取我喜歡的餐廳。<br>所以我準備了一個 JSON 檔案<code>data.json</code>，其內容如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[ </span><br><span class="line">    &#123;<span class="string">"name"</span>: <span class="string">"西堤牛排"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"name"</span>: <span class="string">"欣葉日本料理"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"name"</span>: <span class="string">"屯京拉麵"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"name"</span>: <span class="string">"一番地壽喜燒"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"name"</span>: <span class="string">"銀湯匙"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"name"</span>: <span class="string">"原燒"</span>&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>在我們開始著手讀取 JSON data file 之前，還有兩個不可不知的函數：</p><ul><li><strong>JSON.stringify()</strong></li><li><strong>JSON.parse()</strong></li></ul><h3 id="JavaScript-variable-to-JSON-string"><a href="#JavaScript-variable-to-JSON-string" class="headerlink" title="JavaScript variable to JSON string"></a>JavaScript variable to JSON string</h3><p>利用 <code>JSON.stringify()</code> 函數，我們可以把 JavaScript variable 轉換成 JSON 所表示的 string，範例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rlist = [ </span><br><span class="line">    &#123;<span class="string">"name"</span>: <span class="string">"西堤牛排"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"name"</span>: <span class="string">"欣葉日本料理"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"name"</span>: <span class="string">"屯京拉麵"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"name"</span>: <span class="string">"一番地壽喜燒"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"name"</span>: <span class="string">"銀湯匙"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"name"</span>: <span class="string">"原燒"</span>&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jsonText = <span class="built_in">JSON</span>.stringify(rlist);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> jsonText); <span class="comment">// string</span></span><br></pre></td></tr></table></figure><h3 id="JSON-string-to-JavaScript-variable"><a href="#JSON-string-to-JavaScript-variable" class="headerlink" title="JSON string to JavaScript variable"></a>JSON string to JavaScript variable</h3><p>利用 <code>JSON.parse()</code> 函數，我們可以把 JSON string 轉換成 JavaScript 中可以運用的物件，範例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonText = <span class="string">'[&#123;"name":"西堤牛排"&#125;,&#123;"name":"欣葉日本料理"&#125;,&#123;"name":"屯京拉麵"&#125;,&#123;"name":"一番地壽喜燒"&#125;,&#123;"name":"銀湯匙"&#125;,&#123;"name":"原燒"&#125;]'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rlist = <span class="built_in">JSON</span>.parse(jsonText);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> rlist); <span class="comment">// object</span></span><br></pre></td></tr></table></figure><h2 id="Ajax-非同步載入技術"><a href="#Ajax-非同步載入技術" class="headerlink" title="Ajax 非同步載入技術"></a>Ajax 非同步載入技術</h2><p>開始資料讀取之前，我們先瞭解一下大名鼎鼎的 Ajax 是什麼吧！</p><p><strong>Ajax 即「Asynchronous JavaScript and XML」（非同步的JavaScript與XML技術）</strong>，基本上的核心概念就是<strong>追求提升使用者的體驗</strong>，為了達成這個目的而有動態傳輸的做法。</p><p>Ajax 最大的特色就是可以直接動態傳送、接收資料。相較之下，如果是傳統的網頁技術，Server 在接受指令之後，處理完成後還要再重新導向另一個頁面。</p><p>除此之外也還有其他的好處：</p><ul><li>提升使用者體驗，減少頁面跳轉時產生的落差</li><li>節省網路流量，不傳送重複的版面資訊</li><li>能達到跨平台、跨網域、跨瀏覽器互動的可能</li></ul><p>而 JSON 因小巧與瀏覽器內建快速解析支援，因此較適用於網路資料傳輸領域，是目前常應用在 Ajax 的資料傳輸格式。</p><h2 id="利用-Ajax-讀取資料"><a href="#利用-Ajax-讀取資料" class="headerlink" title="利用 Ajax 讀取資料"></a>利用 Ajax 讀取資料</h2><p>接下來讓我們利用 <code>jQuery.ajax</code> 來讀取放在 Json data file 中的資料，範例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">  url: dataurl,    <span class="comment">// "data.json"</span></span><br><span class="line">  dataType: <span class="string">"json"</span>,</span><br><span class="line">  error: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"error"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  success: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"success"</span>);</span><br><span class="line">    rlist = res;</span><br><span class="line">    update();    <span class="comment">// 負責更新資料的 update function</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>$.ajax()</code> 當中的參數說明：</p><ul><li>url (String)：指定要進行呼叫的位址。</li><li>dataType (String)：返回的資料類型 - xml, html, script, json, jsonp, text。<br>不設定的話 jQuery 會幫你猜返回的內容格式是什麼。</li><li>success：請求成功時執行函式。</li><li>error：請求失敗時執行函式。</li></ul><p>瞭解這些以後，基本上我們就可以利用後端 API 輸出的 JSON string 去處理並呈現網頁上的資料囉！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;之前在學校課程中實作資料庫內容的呈現時，是利用 PHP + MySQL 做資料的傳遞，然而在前後端分離的工作模式之中，只要前端從後端 API 那裡接到產出的資料，就可以直接執行頁面上的資料呈現與處理。&lt;/p&gt;
&lt;p&gt;本文所要實作的內容如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;建構 &lt;strong&gt;JSON data file&lt;/strong&gt; 存放預設資料&lt;/li&gt;
&lt;li&gt;透過 &lt;strong&gt;jQuery 語法 ( Ajax )&lt;/strong&gt; 讀取資料&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;也就是說著重在前端接取資料並呈現的部分，不包含後端產生 JSON data file 的工作。&lt;/p&gt;
&lt;h2 id=&quot;什麼是-JSON&quot;&gt;&lt;a href=&quot;#什麼是-JSON&quot; class=&quot;headerlink&quot; title=&quot;什麼是 JSON&quot;&gt;&lt;/a&gt;什麼是 JSON&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/N4d8OPG.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;strong&gt;JSON（JavaScript Object Notation）&lt;/strong&gt; 是一種輕量級的資料交換語言，後端透過資料庫整理成線上 JSON 格式 ，提供給前端使用，我們可以再經由 jQuery 去存取。&lt;/p&gt;
&lt;p&gt;JSON 支援的資料型態有 string, number, array, object 等等，主要的宣告與 Javascript 無異，只是有些細節要注意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;名稱為字串，必須用成對雙引號 “” 包括&lt;/li&gt;
&lt;li&gt;值可以是雙引號包括的字串、數字、true、false、null、物件或者是陣列。&lt;/li&gt;
&lt;li&gt;不支援 JavaScript 的 Date、Error、規則表示式或函式表示。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="技術心得" scheme="https://blog.weitw.net/categories/%E6%8A%80%E8%A1%93%E5%BF%83%E5%BE%97/"/>
    
    
      <category term="JavaScript" scheme="https://blog.weitw.net/tags/JavaScript/"/>
    
      <category term="jQuery" scheme="https://blog.weitw.net/tags/jQuery/"/>
    
      <category term="AJAX" scheme="https://blog.weitw.net/tags/AJAX/"/>
    
      <category term="JSON" scheme="https://blog.weitw.net/tags/JSON/"/>
    
  </entry>
  
</feed>
